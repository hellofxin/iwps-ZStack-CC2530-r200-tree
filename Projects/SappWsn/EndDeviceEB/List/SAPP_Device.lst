###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               15/Sep/2019  14:22:33
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\SAPP_Device.c
#    Command line       =  
#        -f C:\Users\闫烁\AppData\Local\Temp\EW1A1B.tmp
#        (F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\SAPP_Device.c
#        -D NWK_AUTO_POLL -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D
#        MT_ZDO_FUNC -D SAPP_ZSTACK -lC
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List
#        -lA
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List
#        --diag_suppress Pe001,Pa010 -o
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x4095
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\ -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\ -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mt\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List\SAPP_Device.lst
#    Object file        =  
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\Obj\SAPP_Device.r51
#
###############################################################################

F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\SAPP_Device.c
      1          #if defined(SAPP_ZSTACK)
      2          #include "SAPP_Device.h"

   \                                 In  segment SFR_AN, at 0x90
   \   union <unnamed> volatile __sfr _A_P1
   \                     _A_P1:
   \   000000                DS 1
      3          #include "hal_io.h"
      4          #include <string.h>
      5          
      6          /**************************************************************/
      7          /* 传感器列表                                                 */
      8          /**************************************************************/
      9          /********************************/
     10          /* 燃气传感器                   */
     11          /********************************/
     12          #if defined(HAS_GAS)
     13          #define GAS_IO_GROUP        0
     14          #define GAS_IO_BIT          0
     15          void sensorGasResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
     16          void sensorGasResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
     17          {
     18              if(type == ResInit)
     19              {
     20                  HalIOSetInput(GAS_IO_GROUP, GAS_IO_BIT, Pull_Down);
     21                  HalIOIntSet(ep->ep, GAS_IO_GROUP, GAS_IO_BIT, IOInt_Rising, 0);
     22              }
     23              //IO端口中断触发，中断源检测
     24              if(type == ResIOInt)
     25              {
     26                  uint8 GasValue = 1;
     27                  SendData(ep->ep, &GasValue, 0x0000, TRANSFER_ENDPOINT, sizeof(GasValue));
     28              }
     29          }
     30          void sensorGasTimeout(struct ep_info_t *ep);
     31          void sensorGasTimeout(struct ep_info_t *ep)
     32          {
     33              uint8 value = HalIOGetLevel(GAS_IO_GROUP, GAS_IO_BIT);
     34              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
     35          }
     36          #endif
     37          /********************************/
     38          /* 温度传感器                   */
     39          /********************************/
     40          #if defined(HAS_TEMP) || defined(HAS_HUMM)
     41          #include "sht10.h"
     42          static uint16 TempValue = 0;
     43          #endif
     44          #if defined(HAS_TEMP)
     45          void sensorTempResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
     46          void sensorTempResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
     47          {
     48              if(type == ResInit)
     49              {
     50                  SHT10_init(0x01);
     51              }
     52          }
     53          void sensorTempTimeout(struct ep_info_t *ep);
     54          void sensorTempTimeout(struct ep_info_t *ep)
     55          {
     56              unsigned int value = 0;
     57              unsigned char checksum = 0;
     58              SHT10_Measure(&value,&checksum, TEMPERATURE);
     59              TempValue = (value << 2) - 3960;
     60              SendData(ep->ep, &TempValue, 0x0000, TRANSFER_ENDPOINT, sizeof(TempValue));
     61          }
     62          #endif
     63          /********************************/
     64          /* 湿度传感器                   */
     65          /********************************/
     66          #if defined(HAS_HUMM)
     67          void sensorHummResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
     68          void sensorHummResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
     69          {
     70              if(type == ResInit)
     71              {
     72                  SHT10_init(0x01);
     73              }
     74          }
     75          void sensorHummTimeout(struct ep_info_t *ep);
     76          void sensorHummTimeout(struct ep_info_t *ep)
     77          {
     78              const float C1 = -4.0f;              // for 8 Bit
     79              const float C2 = +0.648f;            // for 8 Bit
     80              const float C3 = -0.0000072f;        // for 8 Bit
     81              const float T1 = 0.01f;              // for 8 bit
     82              const float T2 = 0.00128f;           // for 8 bit
     83              float rh_lin    =   0.0f;                     // rh_lin: Humidity linear
     84              float rh_true   =   0.0f;                    // rh_true: Temperature compensated humidity
     85              float t_C   = 0.0f;                        // t_C   : Temperature []
     86          
     87              unsigned int HumiValue = 0;
     88              unsigned char checksum = 0;
     89              SHT10_Measure(&HumiValue,&checksum, HUMIDITY);
     90              rh_lin=C3*HumiValue*HumiValue + C2*HumiValue + C1;     //calc. humidity from ticks to [%RH]
     91              rh_true=(t_C-25)*(T1+T2*HumiValue)+rh_lin;   //calc. temperature compensated humidity [%RH]
     92              if(rh_true>100)
     93                  rh_true=100;       //cut if the value is outside of
     94              if(rh_true<0.1)
     95                  rh_true=0.1f;       //the physical possible range
     96              HumiValue = (unsigned int)(rh_true * 100);
     97              SendData(ep->ep, &HumiValue, 0x0000, TRANSFER_ENDPOINT, sizeof(HumiValue));
     98          }
     99          #endif
    100          /********************************/
    101          /* 雨滴传感器                   */
    102          /********************************/
    103          #if defined(HAS_RAIN)
    104          #define RAIN_IO_GROUP       0
    105          #define RAIN_IO_BIT         0
    106          void sensorRainResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    107          void sensorRainResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    108          {
    109              if(type == ResInit)
    110              {
    111                  HalIOSetInput(RAIN_IO_GROUP, RAIN_IO_BIT, Pull_None);
    112                  HalIOIntSet(ep->ep, RAIN_IO_GROUP, RAIN_IO_BIT, IOInt_Rising, 0);
    113              }
    114              //IO端口中断触发，中断源检测
    115              if(type == ResIOInt)
    116              {
    117                  uint8 RainValue = 1;
    118                  SendData(ep->ep, &RainValue, 0x0000, TRANSFER_ENDPOINT, sizeof(RainValue));
    119              }
    120          }
    121          void sensorRainTimeout(struct ep_info_t *ep);
    122          void sensorRainTimeout(struct ep_info_t *ep)
    123          {
    124              uint8 value = HalIOGetLevel(RAIN_IO_GROUP, RAIN_IO_BIT);
    125              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    126          }
    127          #endif
    128          /********************************/
    129          /* 火焰传感器                   */
    130          /********************************/
    131          #if defined(HAS_FIRE)
    132          #define FIRE_IO_GROUP       0
    133          #define FIRE_IO_BIT         0
    134          void sensorFireResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    135          void sensorFireResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    136          {
    137              if(type == ResInit)
    138              {
    139                  HalIOSetInput(FIRE_IO_GROUP, FIRE_IO_BIT, Pull_Down);
    140                  HalIOIntSet(ep->ep, FIRE_IO_GROUP, FIRE_IO_BIT, IOInt_Rising, 0);
    141              }
    142              //IO端口中断触发，中断源检测
    143              if(type == ResIOInt)
    144              {
    145                  uint8 FireValue = 1;
    146                  SendData(ep->ep, &FireValue, 0x0000, TRANSFER_ENDPOINT, sizeof(FireValue));
    147              }
    148          }
    149          void sensorFireTimeout(struct ep_info_t *ep);
    150          void sensorFireTimeout(struct ep_info_t *ep)
    151          {
    152              uint8 value = HalIOGetLevel(FIRE_IO_GROUP, FIRE_IO_BIT);
    153              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    154          }
    155          #endif
    156          /********************************/
    157          /* 烟雾传感器                   */
    158          /********************************/
    159          #if defined(HAS_SMOKE)
    160          #define SMOKE_IO_GROUP      0
    161          #define SMOKE_IO_BIT        0
    162          void sensorSmokeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    163          void sensorSmokeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    164          {
    165              if(type == ResInit)
    166              {
    167                  HalIOSetInput(SMOKE_IO_GROUP, SMOKE_IO_BIT, Pull_Down);
    168                  HalIOIntSet(ep->ep, SMOKE_IO_GROUP, SMOKE_IO_BIT, IOInt_Rising, 0);
    169              }
    170              //IO端口中断触发，中断源检测
    171              if(type == ResIOInt)
    172              {
    173                  uint8 SmokeValue = 1;
    174                  SendData(ep->ep, &SmokeValue, 0x0000, TRANSFER_ENDPOINT, sizeof(SmokeValue));
    175              }
    176          }
    177          void sensorSmokeTimeout(struct ep_info_t *ep);
    178          void sensorSmokeTimeout(struct ep_info_t *ep)
    179          {
    180              uint8 value = HalIOGetLevel(SMOKE_IO_GROUP, SMOKE_IO_BIT);
    181              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    182          }
    183          #endif
    184          /********************************/
    185          /* 光照度传感器                 */
    186          /********************************/
    187          #if defined(HAS_ILLUM)
    188          #include "hal_adc.h"
    189          void sensorILLumTimeout(struct ep_info_t *ep);
    190          void sensorILLumTimeout(struct ep_info_t *ep)
    191          {
    192              uint16 LightValue = 256 - (HalAdcRead(0, HAL_ADC_RESOLUTION_14) >> 3);
    193              // 将AD值变换为光照度的100倍
    194              LightValue = LightValue * 39;// * 10000 / 256;
    195              SendData(ep->ep, &LightValue, 0x0000, TRANSFER_ENDPOINT, sizeof(LightValue));
    196          }
    197          #endif
    198          /********************************/
    199          /* 安防传感器                   */
    200          /********************************/
    201          #if defined(HAS_IRPERS)
    202          #define SAFTY_IO_GROUP      1
    203          #define SAFTY_IO_BIT        0
    204          void sensorIRPersResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    205          void sensorIRPersResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    206          {
    207              if(type == ResInit)
    208              {
    209                  HalIOSetInput(SAFTY_IO_GROUP, SAFTY_IO_BIT, Pull_Down);
    210                  HalIOIntSet(ep->ep, SAFTY_IO_GROUP, SAFTY_IO_BIT, IOInt_Rising, 0);
    211              }
    212              //IO端口中断触发，中断源检测
    213              if(type == ResIOInt)
    214              {
    215                  uint8 IRPersValue = 1;
    216                  SendData(ep->ep, &IRPersValue, 0x0000, TRANSFER_ENDPOINT, sizeof(IRPersValue));
    217              }
    218          }
    219          void sensorIRPersTimeout(struct ep_info_t *ep);
    220          void sensorIRPersTimeout(struct ep_info_t *ep)
    221          {
    222              uint8 value = HalIOGetLevel(SAFTY_IO_GROUP, SAFTY_IO_BIT);
    223              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    224          }
    225          #endif
    226          /********************************/
    227          /* 红外测距传感器               */
    228          /********************************/
    229          #if defined(HAS_IRDIST)
    230          #include "hal_adc.h"
    231          extern uint16 irDistTab[256];
    232          void sensorIRDistTimeout(struct ep_info_t *ep);
    233          void sensorIRDistTimeout(struct ep_info_t *ep)
    234          {
    235              uint8 value = HalAdcRead(0, HAL_ADC_RESOLUTION_14) >> 3;
    236              // 计算距离值value的单位为mm
    237              uint16 IRDistValue = irDistTab[value];
    238              SendData(ep->ep, &IRDistValue, 0x0000, TRANSFER_ENDPOINT, sizeof(IRDistValue));
    239          }
    240          #endif
    241          /********************************/
    242          /* 语音传感器                   */
    243          /********************************/
    244          #if defined(HAS_VOICE)
    245          #include "hal_uart.h"
    246          static struct ep_info_t *voiceEndPoint = NULL;
    247          static uint8 LastVoiceData = 0;
    248          static void sensorVoiceUartProcess( uint8 port, uint8 event );
    249          static void sensorVoiceUartProcess( uint8 port, uint8 event )
    250          {
    251              (void)event;  // Intentionally unreferenced parameter
    252              while (Hal_UART_RxBufLen(port))
    253              {
    254                  HalUARTRead(port, &LastVoiceData, 1);
    255                  if(LastVoiceData == 0xAA)
    256                      LastVoiceData = 1;
    257                  else if(LastVoiceData == 0x55)
    258                      LastVoiceData = 0;
    259                  else
    260                      LastVoiceData = -1;
    261                  if(voiceEndPoint != NULL)
    262                      SendData(voiceEndPoint->ep, &LastVoiceData, 0x0000, TRANSFER_ENDPOINT, 1);
    263              }
    264          }
    265          void sensorVoiceNwkStateChange(struct ep_info_t *ep);
    266          void sensorVoiceNwkStateChange(struct ep_info_t *ep)
    267          {
    268              voiceEndPoint = ep;
    269          }
    270          void sensorVoiceResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    271          void sensorVoiceResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    272          {
    273              if(type == ResInit)
    274              {
    275                  halUARTCfg_t uartConfig;
    276          
    277                  voiceEndPoint = ep;
    278                  /* UART Configuration */
    279                  uartConfig.configured           = TRUE;
    280                  uartConfig.baudRate             = HAL_UART_BR_9600;
    281                  uartConfig.flowControl          = FALSE;
    282                  uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
    283                  uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
    284                  uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
    285                  uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
    286                  uartConfig.intEnable            = TRUE;
    287                  uartConfig.callBackFunc         = sensorVoiceUartProcess;
    288                  HalUARTOpen(HAL_UART_PORT_1, &uartConfig);
    289              }
    290          }
    291          void sensorVoiceTimeout(struct ep_info_t *ep);
    292          void sensorVoiceTimeout(struct ep_info_t *ep)
    293          {
    294              uint8 nulData = 0;
    295              SendData(ep->ep, &nulData, 0x0000, TRANSFER_ENDPOINT, 1);
    296          }
    297          #endif
    298          /********************************/
    299          /* 二进制执行器传感器           */
    300          /********************************/
    301          #if defined(HAS_EXECUTEB)
    302          #define ControlInit()   do { HalIOSetOutput(1,4);HalIOSetOutput(1,5);HalIOSetOutput(1,6);HalIOSetOutput(1,7);Control(0); } while(0)
    303          #define Control(mask)   do { HalIOSetLevel(1,4,mask&0x01);HalIOSetLevel(1,5,mask&0x02);HalIOSetLevel(1,6,mask&0x04);HalIOSetLevel(1,7,mask&0x08); } while(0)
    304          void OutputExecuteBResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    305          void OutputExecuteBResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
   \                     OutputExecuteBResAvailable:
    306          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    307              if(type == ResInit)
   \   000007   7401         MOV       A,#0x1
   \   000009   6E           XRL       A,R6
   \   00000A   7040         JNZ       ??OutputExecuteBResAvailable_0
    308                  ControlInit();
   \   00000C                ; Setup parameters for call to function HalIOSetOutput
   \   00000C   7A04         MOV       R2,#0x4
   \   00000E   7901         MOV       R1,#0x1
   \   000010   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   000013                ; Setup parameters for call to function HalIOSetOutput
   \   000013   7A05         MOV       R2,#0x5
   \   000015   7901         MOV       R1,#0x1
   \   000017   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   00001A                ; Setup parameters for call to function HalIOSetOutput
   \   00001A   7A06         MOV       R2,#0x6
   \   00001C   7901         MOV       R1,#0x1
   \   00001E   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   000021                ; Setup parameters for call to function HalIOSetOutput
   \   000021   7A07         MOV       R2,#0x7
   \   000023   7901         MOV       R1,#0x1
   \   000025   12....       LCALL     `??HalIOSetOutput::?relay`; Banked call to: HalIOSetOutput
   \   000028                ; Setup parameters for call to function HalIOSetLevel
   \   000028   7B00         MOV       R3,#0x0
   \   00002A   7A04         MOV       R2,#0x4
   \   00002C   7901         MOV       R1,#0x1
   \   00002E   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   000031                ; Setup parameters for call to function HalIOSetLevel
   \   000031   7B00         MOV       R3,#0x0
   \   000033   7A05         MOV       R2,#0x5
   \   000035   7901         MOV       R1,#0x1
   \   000037   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   00003A                ; Setup parameters for call to function HalIOSetLevel
   \   00003A   7B00         MOV       R3,#0x0
   \   00003C   7A06         MOV       R2,#0x6
   \   00003E   7901         MOV       R1,#0x1
   \   000040   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   000043                ; Setup parameters for call to function HalIOSetLevel
   \   000043   7B00         MOV       R3,#0x0
   \   000045   7A07         MOV       R2,#0x7
   \   000047   7901         MOV       R1,#0x1
   \   000049   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
    309          }
   \                     ??OutputExecuteBResAvailable_0:
   \   00004C   80..         SJMP      ??Subroutine4_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine4_0:
   \   000000   7F01         MOV       R7,#0x1
   \   000002   02....       LJMP      ?BANKED_LEAVE_XDATA
    310          void outputExecuteB(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    311          void outputExecuteB(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
   \                     outputExecuteB:
    312          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   740B         MOV       A,#0xb
   \   00000B   12....       LCALL     ?XSTACK_DISP0_8
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   F8           MOV       R0,A
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   F9           MOV       R1,A
    313              //msg->Data[], msg->DataLength, msg->TransSeqNumber
    314              Control(msg->Data[0]);
   \   000013   E8           MOV       A,R0
   \   000014   2403         ADD       A,#0x3
   \   000016   FE           MOV       R6,A
   \   000017   E4           CLR       A
   \   000018   39           ADDC      A,R1
   \   000019   FF           MOV       R7,A
   \   00001A                ; Setup parameters for call to function HalIOSetLevel
   \   00001A   8E82         MOV       DPL,R6
   \   00001C   F583         MOV       DPH,A
   \   00001E   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   000021   A2E0         MOV       C,0xE0 /* A   */.0
   \   000023   E4           CLR       A
   \   000024   33           RLC       A
   \   000025   FB           MOV       R3,A
   \   000026   7A04         MOV       R2,#0x4
   \   000028   12....       LCALL     ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00002B   5402         ANL       A,#0x2
   \   00002D   FB           MOV       R3,A
   \   00002E   7A05         MOV       R2,#0x5
   \   000030   12....       LCALL     ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   000033   5404         ANL       A,#0x4
   \   000035   FB           MOV       R3,A
   \   000036   7A06         MOV       R2,#0x6
   \   000038   12....       LCALL     ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   00003B   5408         ANL       A,#0x8
   \   00003D   FB           MOV       R3,A
   \   00003E   7A07         MOV       R2,#0x7
   \   000040   7901         MOV       R1,#0x1
   \   000042   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
    315              SendData(ep->ep, &msg->Data[0], 0x0000, TRANSFER_ENDPOINT, 1);
   \   000045                ; Setup parameters for call to function SendData
   \   000045   75..01       MOV       ?V2,#0x1
   \   000048   78..         MOV       R0,#?V2
   \   00004A   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   00004D   78..         MOV       R0,#?V2
   \   00004F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000052   7C00         MOV       R4,#0x0
   \   000054   7D00         MOV       R5,#0x0
   \   000056   8E82         MOV       DPL,R6
   \   000058   8F83         MOV       DPH,R7
   \   00005A   E0           MOVX      A,@DPTR
   \   00005B   FA           MOV       R2,A
   \   00005C   A3           INC       DPTR
   \   00005D   E0           MOVX      A,@DPTR
   \   00005E   FB           MOV       R3,A
   \   00005F   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000062   12....       LCALL     ?DEALLOC_XSTACK8
    316          }
   \   000065   7F03         MOV       R7,#0x3
   \   000067   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   7901         MOV       R1,#0x1
   \   000002   12....       LCALL     `??HalIOSetLevel::?relay`; Banked call to: HalIOSetLevel
   \   000005                ; Setup parameters for call to function HalIOSetLevel
   \   000005                ; Setup parameters for call to function HalIOSetLevel
   \   000005                ; Setup parameters for call to function HalIOSetLevel
   \   000005   8E82         MOV       DPL,R6
   \   000007   8F83         MOV       DPH,R7
   \   000009   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   F8           MOV       R0,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8882         MOV       DPL,R0
   \   000008   E0           MOVX      A,@DPTR
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   E5..         MOV       A,?V0
   \   000002   240B         ADD       A,#0xb
   \   000004   F582         MOV       DPL,A
   \   000006   E4           CLR       A
   \   000007   35..         ADDC      A,?V1
   \   000009   F583         MOV       DPH,A
   \   00000B   E0           MOVX      A,@DPTR
   \   00000C   F9           MOV       R1,A
   \   00000D   12....       LCALL     `??SendData::?relay`; Banked call to: SendData
   \   000010   7402         MOV       A,#0x2
   \   000012   22           RET
    317          void outputExecuteBTimeout(struct ep_info_t *ep);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   EE           MOV       A,R6
   \   000001   240B         ADD       A,#0xb
   \   000003   F582         MOV       DPL,A
   \   000005   E4           CLR       A
   \   000006   3F           ADDC      A,R7
   \   000007   F583         MOV       DPH,A
   \   000009   E0           MOVX      A,@DPTR
   \   00000A   F9           MOV       R1,A
   \   00000B   12....       LCALL     `??SendData::?relay`; Banked call to: SendData
   \   00000E   7402         MOV       A,#0x2
   \   000010   12....       LCALL     ?DEALLOC_XSTACK8
   \   000013   7401         MOV       A,#0x1
   \   000015   12....       LCALL     ?DEALLOC_XSTACK8
   \   000018                REQUIRE ??Subroutine4_0
   \   000018                ; // Fall through to label ??Subroutine4_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    318          void outputExecuteBTimeout(struct ep_info_t *ep)
   \                     outputExecuteBTimeout:
    319          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
    320              uint8 value = P1 >> 4;
   \   00000E   E590         MOV       A,0x90
   \   000010   C4           SWAP      A
   \   000011   540F         ANL       A,#0xf
   \   000013   85..82       MOV       DPL,?XSP + 0
   \   000016   85..83       MOV       DPH,?XSP + 1
   \   000019   F0           MOVX      @DPTR,A
    321              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
   \   00001A                ; Setup parameters for call to function SendData
   \   00001A   75..01       MOV       ?V0,#0x1
   \   00001D   78..         MOV       R0,#?V0
   \   00001F   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000022   78..         MOV       R0,#?V0
   \   000024   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000027   7C00         MOV       R4,#0x0
   \   000029   7D00         MOV       R5,#0x0
   \   00002B   7402         MOV       A,#0x2
   \   00002D   12....       LCALL     ?XSTACK_DISP101_8
   \   000030   02....       LJMP      ?Subroutine0 & 0xFFFF
   \   000033                REQUIRE _A_P1
    322          }
    323          #endif
    324          /********************************/
    325          /* 模拟执行器传感器             */
    326          /********************************/
    327          #if defined(HAS_EXECUTEA)
    328          void outputExecuteA(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
    329          void outputExecuteA(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    330          {
    331          }
    332          #endif
    333          /********************************/
    334          /* 遥控器传感器                 */
    335          /********************************/
    336          #if defined(HAS_REMOTER)
    337          #include "IR.h"

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    338          static uint8 lastCode[32];
   \                     lastCode:
   \   000000                DS 32
   \   000020                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    339          static uint8 lastCodeLen = 0;
   \                     lastCodeLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    340          void IRSendResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    341          void IRSendResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
   \                     IRSendResAvailable:
    342          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV       A,R1
   \   000006   FE           MOV       R6,A
    343              if(type == ResInit)
   \   000007   7401         MOV       A,#0x1
   \   000009   6E           XRL       A,R6
   \   00000A   7003         JNZ       ??IRSendResAvailable_0
    344                  IRSendInit();   // 需要初始化
   \   00000C                ; Setup parameters for call to function IRSendInit
   \   00000C   12....       LCALL     `??IRSendInit::?relay`; Banked call to: IRSendInit
    345          }
   \                     ??IRSendResAvailable_0:
   \   00000F   02....       LJMP      ??Subroutine4_0 & 0xFFFF
    346          void outputRemoter(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    347          void outputRemoter(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
   \                     outputRemoter:
    348          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000                REQUIRE ?V3
   \   000000   74F4         MOV       A,#-0xc
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV       ?V0,R2
   \   000007   8B..         MOV       ?V1,R3
   \   000009   740C         MOV       A,#0xc
   \   00000B   12....       LCALL     ?XSTACK_DISP0_8
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   F8           MOV       R0,A
   \   000010   A3           INC       DPTR
   \   000011   E0           MOVX      A,@DPTR
   \   000012   8882         MOV       DPL,R0
   \   000014   F583         MOV       DPH,A
    349             lastCodeLen = msg->Data[0];
   \   000016   A3           INC       DPTR
   \   000017   A3           INC       DPTR
   \   000018   A3           INC       DPTR
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   F8           MOV       R0,A
   \   00001B   A3           INC       DPTR
   \   00001C   E0           MOVX      A,@DPTR
   \   00001D   F9           MOV       R1,A
   \   00001E   8882         MOV       DPL,R0
   \   000020   F583         MOV       DPH,A
   \   000022   E0           MOVX      A,@DPTR
   \   000023   90....       MOV       DPTR,#lastCodeLen
   \   000026   F0           MOVX      @DPTR,A
    350             memcpy(lastCode, &msg->Data[1], lastCodeLen);
   \   000027   8882         MOV       DPL,R0
   \   000029   8983         MOV       DPH,R1
   \   00002B   A3           INC       DPTR
   \   00002C   AE82         MOV       R6,DPL
   \   00002E   AF83         MOV       R7,DPH
   \   000030                ; Setup parameters for call to function memcpy
   \   000030   F5..         MOV       ?V2,A
   \   000032   75..00       MOV       ?V3,#0x0
   \   000035   78..         MOV       R0,#?V2
   \   000037   12....       LCALL     ?PUSH_XSTACK_I_TWO
   \   00003A   EE           MOV       A,R6
   \   00003B   FC           MOV       R4,A
   \   00003C   EF           MOV       A,R7
   \   00003D   FD           MOV       R5,A
   \   00003E   7A..         MOV       R2,#lastCode & 0xff
   \   000040   7B..         MOV       R3,#(lastCode >> 8) & 0xff
   \   000042   12....       LCALL     `??memcpy::?relay`; Banked call to: memcpy
   \   000045   7402         MOV       A,#0x2
   \   000047   12....       LCALL     ?DEALLOC_XSTACK8
    351             GenIR(&msg->Data[1], IRGuideLen_9ms, (uint8)lastCodeLen);
   \   00004A                ; Setup parameters for call to function GenIR
   \   00004A   90....       MOV       DPTR,#lastCodeLen
   \   00004D   E0           MOVX      A,@DPTR
   \   00004E   FC           MOV       R4,A
   \   00004F   7901         MOV       R1,#0x1
   \   000051   EE           MOV       A,R6
   \   000052   FA           MOV       R2,A
   \   000053   EF           MOV       A,R7
   \   000054   FB           MOV       R3,A
   \   000055   12....       LCALL     `??GenIR::?relay`; Banked call to: GenIR
    352             SendData(ep->ep, lastCode, 0x0000, TRANSFER_ENDPOINT, lastCodeLen>>3);
   \   000058                ; Setup parameters for call to function SendData
   \   000058   90....       MOV       DPTR,#lastCodeLen
   \   00005B   E0           MOVX      A,@DPTR
   \   00005C   13           RRC       A
   \   00005D   13           RRC       A
   \   00005E   13           RRC       A
   \   00005F   541F         ANL       A,#0x1f
   \   000061   F5..         MOV       ?V2,A
   \   000063   78..         MOV       R0,#?V2
   \   000065   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000068   75..01       MOV       ?V2,#0x1
   \   00006B   78..         MOV       R0,#?V2
   \   00006D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000070   7C00         MOV       R4,#0x0
   \   000072   7D00         MOV       R5,#0x0
   \   000074   7A..         MOV       R2,#lastCode & 0xff
   \   000076   7B..         MOV       R3,#(lastCode >> 8) & 0xff
   \   000078   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   00007B   12....       LCALL     ?DEALLOC_XSTACK8
    353          }
   \   00007E   7F04         MOV       R7,#0x4
   \   000080   02....       LJMP      ?BANKED_LEAVE_XDATA
    354          void outputRemoterTimeout(struct ep_info_t *ep);

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    355          void outputRemoterTimeout(struct ep_info_t *ep)
   \                     outputRemoterTimeout:
    356          {
   \   000000                REQUIRE ?V0
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   EA           MOV       A,R2
   \   00000B   FE           MOV       R6,A
   \   00000C   EB           MOV       A,R3
   \   00000D   FF           MOV       R7,A
    357              if(lastCodeLen <= 0)
   \   00000E   90....       MOV       DPTR,#lastCodeLen
   \   000011   E0           MOVX      A,@DPTR
   \   000012   7020         JNZ       ??outputRemoterTimeout_0
    358              {
    359                  uint8 value = 0;
   \   000014   85..82       MOV       DPL,?XSP + 0
   \   000017   85..83       MOV       DPH,?XSP + 1
   \   00001A   E4           CLR       A
   \   00001B   F0           MOVX      @DPTR,A
    360                  SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, 1);
   \   00001C                ; Setup parameters for call to function SendData
   \   00001C   75..01       MOV       ?V0,#0x1
   \   00001F   78..         MOV       R0,#?V0
   \   000021   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000024   78..         MOV       R0,#?V0
   \   000026   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000029   7C00         MOV       R4,#0x0
   \   00002B   7D00         MOV       R5,#0x0
   \   00002D   7402         MOV       A,#0x2
   \   00002F   12....       LCALL     ?XSTACK_DISP101_8
   \   000032   801C         SJMP      ??outputRemoterTimeout_1
    361              }
    362              else
    363                  SendData(ep->ep, lastCode, 0x0000, TRANSFER_ENDPOINT, lastCodeLen>>3);
   \                     ??outputRemoterTimeout_0:
   \   000034                ; Setup parameters for call to function SendData
   \   000034   13           RRC       A
   \   000035   13           RRC       A
   \   000036   13           RRC       A
   \   000037   541F         ANL       A,#0x1f
   \   000039   F5..         MOV       ?V0,A
   \   00003B   78..         MOV       R0,#?V0
   \   00003D   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000040   75..01       MOV       ?V0,#0x1
   \   000043   78..         MOV       R0,#?V0
   \   000045   12....       LCALL     ?PUSH_XSTACK_I_ONE
   \   000048   7C00         MOV       R4,#0x0
   \   00004A   7D00         MOV       R5,#0x0
   \   00004C   7A..         MOV       R2,#lastCode & 0xff
   \   00004E   7B..         MOV       R3,#(lastCode >> 8) & 0xff
   \                     ??outputRemoterTimeout_1:
   \   000050   02....       LJMP      ?Subroutine0 & 0xFFFF
    364          }
    365          #endif
    366          /********************************/
    367          /* 虚拟功能                     */
    368          /********************************/
    369          #if defined(HAS_TESTFUNCTION)
    370          #define TEST_STRING     "Z-Stack for SAPP"
    371          static uint8 lastData[119] = TEST_STRING;
    372          static uint8 lastLen = 0;
    373          void testFunc_RecvData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
    374          void testFunc_RecvData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    375          {
    376              lastLen = msg->DataLength;
    377              memcpy(&lastData[sizeof(TEST_STRING) - 1], msg->Data, lastLen);
    378              SendData(ep->ep, lastData, 0x0000, TRANSFER_ENDPOINT,
    379                               lastLen + sizeof(TEST_STRING) - 1);
    380          }
    381          void testFunc_TimeOut(struct ep_info_t *ep);
    382          void testFunc_TimeOut(struct ep_info_t *ep)
    383          {
    384              SendData(ep->ep, lastData, 0x0000, TRANSFER_ENDPOINT,
    385                               lastLen + sizeof(TEST_STRING) - 1);
    386          }
    387          #endif
    388          /********************************/
    389          /* 广播发送功能                 */
    390          /********************************/
    391          #if defined(HAS_BROADCASTSEND)
    392          #define BROADCAST_STRING     "\r\nBroadcast Message\r\n"
    393          void BroadcastSend_TimeOut(struct ep_info_t *ep);
    394          void BroadcastSend_TimeOut(struct ep_info_t *ep)
    395          {
    396              SendData(ep->ep, BROADCAST_STRING, 0XFFFF, TRANSFER_ENDPOINT,
    397                               sizeof(BROADCAST_STRING) - 1);
    398              //广播后指示灯 LED_D9 闪烁2次
    399              HalLedBlink( HAL_LED_2, 2, 50, 100 );
    400          }
    401          #endif
    402          /********************************/
    403          /* 广播接收功能                 */
    404          /********************************/
    405          #if defined(HAS_BROADCASTRECEIVE)
    406          void BroadcastReceiveData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
    407          void BroadcastReceiveData(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    408          {
    409              //收到广播数据后 LED_D8 连续闪烁4次!
    410              HalLedBlink( HAL_LED_1, 4, 50, 120 );
    411              HalUARTWrite(HAL_UART_PORT_0, msg->Data, msg->DataLength);
    412          }
    413          #define BROADCAST_STRING     "Broadcast Message"
    414          void BroadcastSend_TimeOut(struct ep_info_t *ep);
    415          void BroadcastSend_TimeOut(struct ep_info_t *ep)
    416          {
    417              SendData(ep->ep, BROADCAST_STRING, 0X0000, TRANSFER_ENDPOINT,
    418                               sizeof(BROADCAST_STRING) - 1);
    419          }
    420          #endif
    421          /********************************/
    422          /* IC卡读卡器                   */
    423          /********************************/
    424          #if defined(HAS_125KREADER)
    425          #include "hal_uart.h"
    426          #define CARDID_SIZE     5                   // 卡号长度
    427          static uint8 lastCardId[CARDID_SIZE];       // 用来保存接收到的卡号
    428          static uint8 cardRecvIdx;                   // 上一次接收到的长度
    429          static uint32 lastTick;                     // 上一次接收数据的系统时间
    430          static struct ep_info_t *cardEndPoint;
    431          static void sensor125kReaderUartProcess( uint8 port, uint8 event );
    432          static void sensor125kReaderUartProcess( uint8 port, uint8 event )
    433          {
    434              (void)event;  // Intentionally unreferenced parameter
    435              if((lastTick + 100) <= osal_GetSystemClock())
    436              {                                       // 如果本次接收到的时间距离上次超过了0.1秒
    437                  cardRecvIdx = 0;                    // 则清空计数器，重新接收卡号
    438              }
    439              lastTick = osal_GetSystemClock();       // 记录下当前的时间
    440              while (Hal_UART_RxBufLen(port))
    441              {
    442                  uint16 restLen = Hal_UART_RxBufLen(port);
    443                  if(restLen > (CARDID_SIZE - cardRecvIdx))
    444                      restLen = CARDID_SIZE - cardRecvIdx;
    445                  HalUARTRead(port, &lastCardId[cardRecvIdx], restLen);
    446                  cardRecvIdx += restLen;
    447                  if(cardRecvIdx >= CARDID_SIZE)      // 如果已经接收完成一个完整的卡号
    448                  {                                   // 则发送给协调器
    449                      SendData(cardEndPoint->ep, lastCardId, 0x0000, TRANSFER_ENDPOINT, CARDID_SIZE);
    450                  }
    451              }
    452          }
    453          void sensor125kReaderResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    454          void sensor125kReaderResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    455          {
    456              if(type == ResInit)
    457              {
    458                  halUARTCfg_t uartConfig;
    459          
    460                  memset(lastCardId, 0, sizeof(lastCardId));
    461                  cardRecvIdx = 0;
    462                  cardEndPoint = ep;
    463                  /* UART Configuration */
    464                  uartConfig.configured           = TRUE;
    465                  uartConfig.baudRate             = HAL_UART_BR_19200;
    466                  uartConfig.flowControl          = FALSE;
    467                  uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
    468                  uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
    469                  uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
    470                  uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
    471                  uartConfig.intEnable            = TRUE;
    472                  uartConfig.callBackFunc         = sensor125kReaderUartProcess;
    473                  HalUARTOpen(HAL_UART_PORT_0, &uartConfig);
    474              }
    475          }
    476          void sensor125kReaderTimeout(struct ep_info_t *ep);
    477          void sensor125kReaderTimeout(struct ep_info_t *ep)
    478          {
    479              uint8 nullId[CARDID_SIZE] = { 0x00 };
    480              SendData(cardEndPoint->ep, nullId, 0x0000, TRANSFER_ENDPOINT, CARDID_SIZE);
    481          }
    482          #endif
    483          /********************************/
    484          /* 语音播放节点                 */
    485          /********************************/
    486          #if defined(HAS_SPEAKER)
    487          void OutputSpeakerResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    488          void OutputSpeakerResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    489          {
    490              if(type == ResInit)
    491                  HalUART1HwInit();
    492          }
    493          void outputSpeaker(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg);
    494          void outputSpeaker(struct ep_info_t *ep, uint16 addr, uint8 endPoint, afMSGCommandFormat_t *msg)
    495          {
    496              //msg->Data[], msg->DataLength, msg->TransSeqNumber
    497              HalUART1HwTxByte(msg->Data[0]);
    498          //    SendData(ep->ep, &msg->Data[0], 0x0000, TRANSFER_ENDPOINT, 1);
    499          }
    500          void outputSpeakerTimeout(struct ep_info_t *ep);
    501          void outputSpeakerTimeout(struct ep_info_t *ep)
    502          {
    503              uint8 value = 0;
    504              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    505          }
    506          #endif
    507          /********************************/
    508          /* 红外接收解码                 */
    509          /********************************/
    510          #if defined(HAS_IRDecode)
    511          #include <hal_irdec.h>
    512          void IRDecodeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res);
    513          void IRDecodeResAvailable(struct ep_info_t *ep, RES_TYPE type, void *res)
    514          {
    515              if(type == ResInit)
    516              {
    517                  IRDecodeT1Init(ep->task_id, ep->ep);
    518              }
    519              //定时器1通道0一次红外解码结束,向上传送解码结果
    520              if(type == ResTimerInt)
    521              {
    522                  OSALIRDecData_t *irData = (OSALIRDecData_t *)res;
    523                  SendData(ep->ep, irData->irCode, 0x0000, TRANSFER_ENDPOINT, irData->irLen);
    524              }
    525          }
    526          void IRDecodeTimeout(struct ep_info_t *ep);
    527          void IRDecodeTimeout(struct ep_info_t *ep)
    528          {
    529              uint8 value = 0;
    530              SendData(ep->ep, &value, 0x0000, TRANSFER_ENDPOINT, sizeof(value));
    531          }
    532          #endif
    533          /***************************************************/
    534          /* 节点功能列表                                    */
    535          /***************************************************/

   \                                 In  segment XDATA_I, align 1, keep-with-next
    536          struct ep_info_t funcList[] = {
   \                     funcList:
   \   000000                DS 66
   \   000042                REQUIRE `?<Initializer for funcList>`
   \   000042                REQUIRE __INIT_XDATA_I
    537          #if defined(HAS_GAS)
    538              {
    539                  // 加入网络,收到数据,超时处理,资源变化
    540                  NULL, NULL, sensorGasTimeout, sensorGasResAvailable,
    541                  { DevGas, 0, 5 },                   // type, id, refresh cycle
    542              },
    543          #endif
    544          #if defined(HAS_TEMP)
    545              {
    546                  NULL, NULL, sensorTempTimeout, sensorTempResAvailable,
    547                  { DevTemp, 1, 3 },                 // type, id, refresh cycle
    548              },
    549          #endif
    550          #if defined(HAS_HUMM)
    551              {
    552                  NULL, NULL, sensorHummTimeout, sensorHummResAvailable,
    553                  { DevHumm, 0, 3 },                 // type, id, refresh cycle
    554              },
    555          #endif
    556          #if defined(HAS_ILLUM)
    557              {
    558                  NULL, NULL, sensorILLumTimeout, NULL,
    559                  { DevILLum, 0, 3 },                // type, id, refresh cycle
    560              },
    561          #endif
    562          #if defined(HAS_RAIN)
    563              {
    564                  NULL, NULL, sensorRainTimeout, sensorRainResAvailable,
    565                  { DevRain, 0, 5 },                 // type, id, refresh cycle
    566              },
    567          #endif
    568          #if defined(HAS_IRDIST)
    569              {
    570                  NULL, NULL, sensorIRDistTimeout, NULL,
    571                  { DevIRDist, 0, 3 },               // type, id, refresh cycle
    572              },
    573          #endif
    574          #if defined(HAS_SMOKE)
    575              {
    576                  NULL, NULL, sensorSmokeTimeout, sensorSmokeResAvailable,
    577                  { DevSmoke, 0, 5 },                 // type, id, refresh cycle
    578              },
    579          #endif
    580          #if defined(HAS_FIRE)
    581              {
    582                  NULL, NULL, sensorFireTimeout, sensorFireResAvailable,
    583                  { DevFire, 0, 3 },                  // type, id, refresh cycle
    584              },
    585          #endif
    586          #if defined(HAS_IRPERS)
    587              {
    588                  NULL, NULL, sensorIRPersTimeout, sensorIRPersResAvailable,
    589                  { DevIRPers, 0, 2 },                // type, id, refresh cycle
    590              },
    591          #endif
    592          #if defined(HAS_VOICE)
    593              {
    594                  sensorVoiceNwkStateChange, NULL, sensorVoiceTimeout, sensorVoiceResAvailable,
    595                  { DevVoice, 0, 5 },                // type, id, refresh cycle
    596              },
    597          #endif
    598          #if defined(HAS_EXECUTEB)
    599              {
    600                  NULL, outputExecuteB, outputExecuteBTimeout, OutputExecuteBResAvailable,
    601                  { DevExecuteB, 3, 5 },              // type, id, refresh cycle
    602              },
    603          #endif
    604          #if defined(HAS_EXECUTEA)
    605              {
    606                  NULL, outputExecuteA, NULL, NULL,
    607                  { DevExecuteA, 0, 3 },              // type, id, refresh cycle
    608              },
    609          #endif
    610          #if defined(HAS_REMOTER)
    611              {
    612                  NULL, outputRemoter, outputRemoterTimeout, IRSendResAvailable,
    613                  { DevRemoter, 0, 3 },              // type, id, refresh cycle
    614              },
    615          #endif
    616          #if defined(HAS_TESTFUNCTION)
    617              {
    618                  NULL,
    619                  testFunc_RecvData,
    620                  testFunc_TimeOut,
    621                  NULL,
    622                  { DevTest, 0, 3 },
    623              },
    624          #endif
    625          #if defined(HAS_BROADCASTSEND)
    626              {
    627                  NULL,
    628                  NULL,
    629                  BroadcastSend_TimeOut,
    630                  NULL,
    631                  { DevBroadcastSend, 0, 3 },
    632              },
    633          #endif
    634          #if defined(HAS_BROADCASTRECEIVE)
    635              {
    636                  NULL,
    637                  BroadcastReceiveData,
    638                  BroadcastSend_TimeOut,
    639                  NULL,
    640                  { DevBroadcastReceive, 0, 30 },
    641              },
    642          #endif
    643          #if defined(HAS_125KREADER)
    644              {
    645                  NULL, NULL, sensor125kReaderTimeout, sensor125kReaderResAvailable,
    646                  { Dev125kReader, 0, 10 },
    647              },
    648          #endif
    649          #if defined(HAS_SPEAKER)
    650              {
    651                  NULL, outputSpeaker, outputSpeakerTimeout, OutputSpeakerResAvailable,
    652                  { DevSpeaker, 0, 9 },              // type, id, refresh cycle
    653              },
    654          #endif
    655          #if defined(HAS_IRDecode)
    656              {
    657                  NULL, NULL, IRDecodeTimeout, IRDecodeResAvailable,
    658                  { DevIRDecode, 0, 5 },              // type, id, refresh cycle
    659              },
    660          #endif
    661          #if defined(ZDO_COORDINATOR)
    662              {   // 协调器
    663                  CoordinatorNwkStateChangeRoutine,
    664                  CoordinatorIncomingRoutine,
    665                  CoordinatorTimeoutRoutine,
    666                  CoordinatorResAvailableRoutine,
    667                  { DevCoordinator, 0, 0 },
    668              },
    669          #elif defined(RTR_NWK)
    670              {   // 路由器
    671                  RouterNwkStateChangeRoutine,
    672                  RouterIncomingRoutine,
    673                  RouterTimeoutRoutine,
    674                  RouterResAvailableRoutine,
    675                  { DevRouter, 0, 30 },
    676              },
    677          #endif
    678          };
    679          
    680          // 不能修改下面的内容!!!

   \                                 In  segment XDATA_ROM_C, align 1
    681          const uint8 funcCount = sizeof(funcList) / sizeof(funcList[0]);
   \                     funcCount:
   \   000000   02           DB 2

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for funcList>`:
   \   000000   0000         DW 0H
   \   000002   ....         DW `??outputExecuteB::?relay`
   \   000004   ....         DW `??outputExecuteBTimeout::?relay`
   \   000006   ....         DW `??OutputExecuteBResAvailable::?relay`
   \   000008   0B           DB 11
   \   000009   03           DB 3
   \   00000A   05           DB 5
   \   00000B   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000013   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00001B   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    
   \   000021   0000         DW 0H
   \   000023   ....         DW `??outputRemoter::?relay`
   \   000025   ....         DW `??outputRemoterTimeout::?relay`
   \   000027   ....         DW `??IRSendResAvailable::?relay`
   \   000029   0D           DB 13
   \   00002A   00           DB 0
   \   00002B   03           DB 3
   \   00002C   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   000034   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \   00003C   00000000     DB 0, 0, 0, 0, 0, 0
   \            0000    
    682          #endif

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0      9   IRSendResAvailable
        0      9   -> IRSendInit
      0      9   OutputExecuteBResAvailable
        0      9   -> HalIOSetLevel
        0      9   -> HalIOSetOutput
      0     15   outputExecuteB
        0     11   -> HalIOSetLevel
        0     13   -> SendData
      1     12   outputExecuteBTimeout
        0     12   -> SendData
      0     16   outputRemoter
        0     12   -> GenIR
        0     14   -> SendData
        0     14   -> memcpy
      0     12   outputRemoterTimeout
        0     12   -> SendData


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
      66  ?<Initializer for funcList>
       5  ??Subroutine4_0
      24  ?Subroutine0
      13  ?Subroutine1
      19  ?Subroutine2
      10  ?Subroutine3
      18  IRSendResAvailable
      78  OutputExecuteBResAvailable
       1  _A_P1
       1  funcCount
      66  funcList
      32  lastCode
       1  lastCodeLen
     106  outputExecuteB
      51  outputExecuteBTimeout
     131  outputRemoter
      83  outputRemoterTimeout
      36  -- Other

 
 538 bytes in segment BANKED_CODE
  36 bytes in segment BANK_RELAYS
   1 byte  in segment SFR_AN
  66 bytes in segment XDATA_I
  66 bytes in segment XDATA_ID
   1 byte  in segment XDATA_ROM_C
  33 bytes in segment XDATA_Z
 
 102 bytes of CODE     memory
   1 byte  of CONST    memory
   0 bytes of DATA     memory (+ 1 byte shared)
 538 bytes of HUGECODE memory
  99 bytes of XDATA    memory

Errors: none
Warnings: none
