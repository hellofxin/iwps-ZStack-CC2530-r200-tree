###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               15/Sep/2019  14:22:31
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Components\mt\MT_SYS.c
#    Command line       =  
#        -f C:\Users\ãÆË¸\AppData\Local\Temp\EW1336.tmp
#        (F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Components\mt\MT_SYS.c -D
#        NWK_AUTO_POLL -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D MT_ZDO_FUNC
#        -D SAPP_ZSTACK -lC
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List
#        -lA
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List
#        --diag_suppress Pe001,Pa010 -o
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x4095
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\ -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\ -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mt\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List\MT_SYS.lst
#    Object file        =  
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\Obj\MT_SYS.r51
#
###############################################################################

F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Components\mt\MT_SYS.c
      1          /******************************************************************************
      2            Filename:       MT_SYS.c
      3            Revised:        $Date: 2011-06-05 18:52:21 -0700 (Sun, 05 Jun 2011) $
      4            Revision:       $Revision: 26212 $
      5          
      6            Description:   MonitorTest functions for SYS commands.
      7          
      8            Copyright 2007-2011 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License"). You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product. Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38           *****************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "MT.h"
     45          #include "MT_SYS.h"
     46          #include "MT_VERSION.h"
     47          #include "nwk_util.h"
     48          #include "OSAL.h"
     49          #include "OSAL_NV.h"
     50          #include "Onboard.h"  /* This is here because RAM read/write macros need it */

   \                                 In  segment SFR_AN, at 0x9d
   \   unsigned char volatile __sfr SLEEPSTA
   \                     SLEEPSTA:
   \   000000                DS 1
     51          #include "hal_adc.h"
     52          #include "ZGlobals.h"
     53          #include "OSAL_Clock.h"
     54          
     55          /***************************************************************************************************
     56           * MACROS
     57           ***************************************************************************************************/
     58          
     59          #define MT_SYS_DEVICE_INFO_RESPONSE_LEN 14
     60          #define MT_NV_ITEM_MAX_LENGTH           250
     61          
     62          #if !defined HAL_GPIO || !HAL_GPIO
     63          #define GPIO_DIR_IN(IDX)
     64          #define GPIO_DIR_OUT(IDX)
     65          #define GPIO_TRI(IDX)
     66          #define GPIO_PULL_UP(IDX)
     67          #define GPIO_PULL_DN(IDX)
     68          #define GPIO_SET(IDX)
     69          #define GPIO_CLR(IDX)
     70          #define GPIO_TOG(IDX)
     71          #define GPIO_GET(IDX) 0
     72          #define GPIO_HiD_SET() (val = 0)
     73          #define GPIO_HiD_CLR() (val = 0)
     74          #endif
     75          
     76          /***************************************************************************************************
     77           * CONSTANTS
     78           ***************************************************************************************************/
     79          
     80          #if !defined MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA
     81          #define MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA  FALSE
     82          #endif
     83          

   \                                 In  segment XDATA_ROM_C, align 1
     84          const uint16 MT_SysOsalEventId [] = {
   \                     MT_SysOsalEventId:
   \   000000   0008         DW 2048
   \   000002   0004         DW 1024
   \   000004   0002         DW 512
   \   000006   0001         DW 256
     85                                                MT_SYS_OSAL_EVENT_0,
     86                                                MT_SYS_OSAL_EVENT_1,
     87                                                MT_SYS_OSAL_EVENT_2,
     88                                                MT_SYS_OSAL_EVENT_3
     89                                              };
     90          
     91          typedef enum {
     92            GPIO_DIR,
     93            GPIO_TRI,
     94            GPIO_SET,
     95            GPIO_CLR,
     96            GPIO_TOG,
     97            GPIO_GET,
     98            GPIO_HiD = 0x12
     99          } GPIO_Op_t;
    100          
    101          /***************************************************************************************************
    102           * LOCAL FUNCTIONS
    103           ***************************************************************************************************/
    104          #if defined (MT_SYS_FUNC)
    105          void MT_SysReset(uint8 *pBuf);
    106          void MT_SysPing(void);
    107          void MT_SysVersion(void);
    108          void MT_SysSetExtAddr(uint8 *pBuf);
    109          void MT_SysGetExtAddr(void);
    110          void MT_SysOsalNVItemInit(uint8 *pBuf);
    111          void MT_SysOsalNVDelete(uint8 *pBuf);
    112          void MT_SysOsalNVLength(uint8 *pBuf);
    113          void MT_SysOsalNVRead(uint8 *pBuf);
    114          void MT_SysOsalNVWrite(uint8 *pBuf);
    115          void MT_SysOsalStartTimer(uint8 *pBuf);
    116          void MT_SysOsalStopTimer(uint8 *pBuf);
    117          void MT_SysRandom(void);
    118          void MT_SysAdcRead(uint8 *pBuf);
    119          void MT_SysGpio(uint8 *pBuf);
    120          void MT_SysStackTune(uint8 *pBuf);
    121          void MT_SysGetDeviceInfo(uint8 *pBuf);
    122          void MT_SysSetUtcTime(uint8 *pBuf);
    123          void MT_SysGetUtcTime(void);
    124          #endif /* MT_SYS_FUNC */
    125          
    126          #if defined (MT_SYS_FUNC)
    127          /***************************************************************************************************
    128           * @fn      MT_SysProcessing
    129           *
    130           * @brief   Process all the SYS commands that are issued by test tool
    131           *
    132           * @param   pBuf - pointer to the msg buffer
    133           *
    134           *          | LEN  | CMD0  | CMD1  |  DATA  |
    135           *          |  1   |   1   |   1   |  0-255 |
    136           *
    137           * @return  status
    138           ***************************************************************************************************/
    139          uint8 MT_SysCommandProcessing(uint8 *pBuf)
    140          {
    141            uint8 status = MT_RPC_SUCCESS;
    142          
    143            switch (pBuf[MT_RPC_POS_CMD1])
    144            {
    145              case MT_SYS_RESET_REQ:
    146                MT_SysReset(pBuf);
    147                break;
    148          
    149              case MT_SYS_PING:
    150                MT_SysPing();
    151                break;
    152          
    153              case MT_SYS_VERSION:
    154                MT_SysVersion();
    155                break;
    156          
    157              case MT_SYS_SET_EXTADDR:
    158                MT_SysSetExtAddr(pBuf);
    159                break;
    160          
    161              case MT_SYS_GET_EXTADDR:
    162                MT_SysGetExtAddr();
    163                break;
    164          
    165          // CC253X MAC Network Processor does not have NV support
    166          #if !defined(CC253X_MACNP)
    167              case MT_SYS_OSAL_NV_DELETE:
    168                MT_SysOsalNVDelete(pBuf);
    169                break;
    170          
    171              case MT_SYS_OSAL_NV_ITEM_INIT:
    172                MT_SysOsalNVItemInit(pBuf);
    173                break;
    174          
    175              case MT_SYS_OSAL_NV_LENGTH:
    176                MT_SysOsalNVLength(pBuf);
    177                break;
    178          
    179              case MT_SYS_OSAL_NV_READ:
    180                MT_SysOsalNVRead(pBuf);
    181                break;
    182          
    183              case MT_SYS_OSAL_NV_WRITE:
    184                MT_SysOsalNVWrite(pBuf);
    185                break;
    186          #endif
    187          
    188              case MT_SYS_OSAL_START_TIMER:
    189                MT_SysOsalStartTimer(pBuf);
    190                break;
    191          
    192              case MT_SYS_OSAL_STOP_TIMER:
    193                MT_SysOsalStopTimer(pBuf);
    194                break;
    195          
    196              case MT_SYS_RANDOM:
    197                MT_SysRandom();
    198                break;
    199          
    200              case MT_SYS_ADC_READ:
    201                MT_SysAdcRead(pBuf);
    202                break;
    203          
    204              case MT_SYS_GPIO:
    205                MT_SysGpio(pBuf);
    206                break;
    207          
    208              case MT_SYS_STACK_TUNE:
    209                MT_SysStackTune(pBuf);
    210                break;
    211          
    212              case MT_SYS_SET_TIME:
    213                MT_SysSetUtcTime(pBuf);
    214                break;
    215          
    216              case MT_SYS_GET_TIME:
    217                MT_SysGetUtcTime();
    218                break;
    219          
    220              default:
    221                status = MT_RPC_ERR_COMMAND_ID;
    222                break;
    223            }
    224          
    225            return status;
    226          }
    227          
    228          /**************************************************************************************************
    229           * @fn      MT_SysReset
    230           *
    231           * @brief   Reset the device.
    232           * @param   typID: 0=reset, 1=serial bootloader
    233           *
    234           * @return  None
    235           *************************************************************************************************/
    236          void MT_SysReset(uint8 *pBuf)
    237          {
    238            if (pBuf[MT_RPC_POS_DAT0] == 0)
    239            {
    240              SystemReset();
    241            }
    242          #if !(defined(HAL_BOARD_F2618) || defined(HAL_BOARD_F5438) || defined(HAL_BOARD_LM3S))
    243            else
    244            {
    245              SystemResetSoft();  // Especially useful for CC2531 to not break comm with USB Host.
    246            }
    247          #endif
    248          
    249          }
    250          
    251          /***************************************************************************************************
    252           * @fn      MT_SysPing
    253           *
    254           * @brief   Process the Ping command
    255           *
    256           * @param   None
    257           *
    258           * @return  None
    259           ***************************************************************************************************/
    260          void MT_SysPing(void)
    261          {
    262            uint16 tmp16;
    263            uint8 retArray[2];
    264          
    265            /* Build Capabilities */
    266            tmp16 = MT_CAP_SYS | MT_CAP_MAC | MT_CAP_NWK | MT_CAP_AF | MT_CAP_ZDO |
    267                    MT_CAP_SAPI | MT_CAP_UTIL | MT_CAP_DEBUG | MT_CAP_APP | MT_CAP_ZOAD;
    268          
    269            /* Convert to high byte first into temp buffer */
    270            retArray[0] = LO_UINT16( tmp16 );
    271            retArray[1] = HI_UINT16( tmp16 );
    272          
    273            /* Build and send back the response */
    274            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), MT_SYS_PING,
    275                                          sizeof (tmp16), retArray );
    276          }
    277          
    278          /***************************************************************************************************
    279           * @fn      MT_SysVersion
    280           *
    281           * @brief   Process the Version command
    282           *
    283           * @param   None
    284           *
    285           * @return  None
    286           ***************************************************************************************************/
    287          void MT_SysVersion(void)
    288          {
    289            byte *verStr = (byte *)MTVersionString;
    290            uint8 respLen = sizeof(MTVersionString);
    291          
    292            /* Build and send back the response */
    293            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), MT_SYS_VERSION,
    294                                         respLen, verStr);
    295          }
    296          
    297          /***************************************************************************************************
    298           * @fn      MT_SysSetExtAddr
    299           *
    300           * @brief   Set the Extended Address
    301           *
    302           * @param   pBuf
    303           *
    304           * @return  None
    305           ***************************************************************************************************/
    306          void MT_SysSetExtAddr(uint8 *pBuf)
    307          {
    308            uint8 retValue = ZFailure;
    309            uint8 cmdId;
    310          
    311            /* parse header */
    312            cmdId = pBuf[MT_RPC_POS_CMD1];
    313            pBuf += MT_RPC_FRAME_HDR_SZ;
    314          
    315            if ( ZMacSetReq(ZMacExtAddr, pBuf) == ZMacSuccess )
    316            {
    317          // CC253X MAC Network Processor does not have NV support
    318          #if !defined(CC253X_MACNP)
    319              retValue = osal_nv_write(ZCD_NV_EXTADDR, 0, Z_EXTADDR_LEN, pBuf);
    320          #endif
    321            }
    322          
    323            /* Build and send back the response */
    324            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmdId, 1, &retValue);
    325          
    326          }
    327          
    328          /***************************************************************************************************
    329           * @fn      MT_SysGetExtAddr
    330           *
    331           * @brief   Get the Extended Address
    332           *
    333           * @param   None
    334           *
    335           * @return  None
    336           ***************************************************************************************************/
    337          void MT_SysGetExtAddr(void)
    338          {
    339            uint8 extAddr[Z_EXTADDR_LEN];
    340          
    341            ZMacGetReq( ZMacExtAddr, extAddr );
    342          
    343            /* Build and send back the response */
    344            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), MT_SYS_GET_EXTADDR,
    345                                         Z_EXTADDR_LEN, extAddr);
    346          }
    347          
    348          /***************************************************************************************************
    349           * @fn      MT_SysOsalNVRead
    350           *
    351           * @brief  Read a NV value
    352           *
    353           * @param  uint8 pBuf - pointer to the data
    354           *
    355           * @return  None
    356           ***************************************************************************************************/
    357          void MT_SysOsalNVRead(uint8 *pBuf)
    358          {
    359            uint16 nvId;
    360            uint8 nvItemLen=0, nvItemOffset=0;
    361            uint8 *pRetBuf=NULL;
    362            uint8 respLen;
    363          
    364            /* Skip over RPC header */
    365            pBuf += MT_RPC_FRAME_HDR_SZ;
    366          
    367            /* Get the ID */
    368            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
    369            /* Get the offset */
    370            nvItemOffset = pBuf[2];
    371          
    372          #if !MT_SYS_OSAL_NV_READ_CERTIFICATE_DATA
    373            if ((ZCD_NV_IMPLICIT_CERTIFICATE == nvId) ||
    374                (ZCD_NV_CA_PUBLIC_KEY == nvId)        ||
    375                (ZCD_NV_DEVICE_PRIVATE_KEY == nvId))
    376            {
    377              uint8 tmp[2] = { INVALIDPARAMETER, 0 };
    378              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    379                                             MT_SYS_OSAL_NV_READ, 2, tmp);
    380              return;
    381            }
    382          #endif
    383          
    384          #if !MT_SYS_KEY_MANAGEMENT
    385            if ( (nvId == ZCD_NV_NWK_ACTIVE_KEY_INFO) ||
    386                 (nvId == ZCD_NV_NWK_ALTERN_KEY_INFO) ||
    387                ((nvId >= ZCD_NV_TCLK_TABLE_START) && (nvId <= ZCD_NV_TCLK_TABLE_END)) ||
    388                ((nvId >= ZCD_NV_APS_LINK_KEY_DATA_START) && (nvId <= ZCD_NV_APS_LINK_KEY_DATA_END)) ||
    389                ((nvId >= ZCD_NV_MASTER_KEY_DATA_START) && (nvId <= ZCD_NV_MASTER_KEY_DATA_END)) ||
    390                 (nvId == ZCD_NV_PRECFGKEY) )
    391            {
    392              uint8 tmp1[2] = { INVALIDPARAMETER, 0 };
    393              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    394                                             MT_SYS_OSAL_NV_READ, 2, tmp1);
    395              return;
    396            }
    397          #endif //!MT_SYS_KEY_MANAGEMENT
    398          
    399            nvItemLen = osal_nv_item_len(nvId);
    400          
    401            /* Return only 250 bytes max */
    402            if (nvItemLen > MT_NV_ITEM_MAX_LENGTH)
    403            {
    404              nvItemLen = MT_NV_ITEM_MAX_LENGTH;
    405            }
    406          
    407            if ((nvItemLen > 0) && ((nvItemLen - nvItemOffset) > 0))
    408            {
    409              respLen = nvItemLen - nvItemOffset + 2;
    410            }
    411            else
    412            {
    413              respLen = 2;
    414            }
    415          
    416            pRetBuf = osal_mem_alloc(respLen);
    417          
    418            if (pRetBuf != NULL)
    419            {
    420              osal_memset(pRetBuf, 0, respLen);
    421          
    422              /* Default to ZFailure */
    423              pRetBuf[0] = ZFailure;
    424          
    425              if (respLen > 2)
    426              {
    427                if (((osal_nv_read( nvId, (uint16)nvItemOffset, (uint16)nvItemLen, &pRetBuf[2])) == ZSUCCESS) && (respLen > 2))
    428                {
    429                  pRetBuf[0] = ZSuccess;
    430                }
    431                pRetBuf[1] = nvItemLen - nvItemOffset;
    432              }
    433              else
    434              {
    435                pRetBuf[1] = 0;
    436              }
    437          
    438              /* Build and send back the response */
    439              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    440                                             MT_SYS_OSAL_NV_READ, respLen, pRetBuf );
    441          
    442              osal_mem_free(pRetBuf);
    443            }
    444          }
    445          
    446          /***************************************************************************************************
    447           * @fn      MT_SysOsalNVWrite
    448           *
    449           * @brief
    450           *
    451           * @param   uint8 pData - pointer to the data
    452           *
    453           * @return  None
    454           ***************************************************************************************************/
    455          void MT_SysOsalNVWrite(uint8 *pBuf)
    456          {
    457            uint16 nvId;
    458            uint8 nvItemLen=0, nvItemOffset=0;
    459            uint8 rtrn;
    460          
    461            /* Skip over RPC header */
    462            pBuf += MT_RPC_FRAME_HDR_SZ;
    463          
    464            /* Get the ID */
    465            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
    466            /* Get the offset */
    467            nvItemOffset = pBuf[2];
    468            /* Get the length */
    469            nvItemLen = pBuf[3];
    470            pBuf += 4;
    471          
    472            /* Default to ZFailure */
    473            rtrn = ZFailure;
    474          
    475            /* Set the Z-Globals value of this NV item. */
    476            zgSetItem( nvId, (uint16)nvItemLen, pBuf );
    477          
    478            if ((osal_nv_write(nvId, (uint16)nvItemOffset, (uint16)nvItemLen, pBuf)) == ZSUCCESS)
    479            {
    480              if (nvId == ZCD_NV_EXTADDR)
    481              {
    482                rtrn = ZMacSetReq(ZMacExtAddr, pBuf);
    483              }
    484              else
    485              {
    486                rtrn = ZSuccess;
    487              }
    488            }
    489          
    490            /* Build and send back the response */
    491            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    492                                           MT_SYS_OSAL_NV_WRITE, 1, &rtrn);
    493          }
    494          
    495          /***************************************************************************************************
    496           * @fn      MT_SysOsalNVItemInit
    497           *
    498           * @brief   Attempt to create an NV item
    499           *
    500           * @param   uint8 pData - pointer to the data
    501           *
    502           * @return  None
    503           ***************************************************************************************************/
    504          void MT_SysOsalNVItemInit(uint8 *pBuf)
    505          {
    506            uint8 ret;
    507            uint8 idLen;
    508            uint16 nvId;
    509            uint16 nvLen;
    510          
    511            /* Skip over RPC header */
    512            pBuf += MT_RPC_FRAME_HDR_SZ;
    513          
    514            /* NV item ID */
    515            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
    516            /* NV item length */
    517            nvLen = BUILD_UINT16(pBuf[2], pBuf[3]);
    518            /* Initialization data length */
    519            idLen = pBuf[4];
    520            pBuf += 5;
    521          
    522            if ( idLen < nvLen )
    523            {
    524              /* Attempt to create a new NV item */
    525              ret = osal_nv_item_init( nvId, nvLen, NULL );
    526              if ( (ret == NV_ITEM_UNINIT) && (idLen > 0) )
    527              {
    528                /* Write initialization data to first part of new item */
    529                (void) osal_nv_write( nvId, 0, (uint16)idLen, pBuf );
    530              }
    531            }
    532            else
    533            {
    534              /* Attempt to create/initialize a new NV item */
    535              ret = osal_nv_item_init( nvId, nvLen, pBuf );
    536            }
    537          
    538            /* Build and send back the response */
    539            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    540                                           MT_SYS_OSAL_NV_ITEM_INIT, 1, &ret);
    541          }
    542          
    543          /***************************************************************************************************
    544           * @fn      MT_SysOsalNVDelete
    545           *
    546           * @brief   Attempt to delete an NV item
    547           *
    548           * @param   uint8 pData - pointer to the data
    549           *
    550           * @return  None
    551           ***************************************************************************************************/
    552          void MT_SysOsalNVDelete(uint8 *pBuf)
    553          {
    554            uint16 nvId;
    555            uint16 nvLen;
    556            uint8 ret;
    557          
    558            /* Skip over RPC header */
    559            pBuf += MT_RPC_FRAME_HDR_SZ;
    560          
    561            /* Get the ID */
    562            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
    563            /* Get the length */
    564            nvLen = BUILD_UINT16(pBuf[2], pBuf[3]);
    565          
    566            /* Attempt to delete the NV item */
    567            ret = osal_nv_delete( nvId, nvLen );
    568          
    569            /* Build and send back the response */
    570            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    571                                           MT_SYS_OSAL_NV_DELETE, 1, &ret);
    572          }
    573          
    574          /***************************************************************************************************
    575           * @fn      MT_SysOsalNVLength
    576           *
    577           * @brief   Attempt to get the length to an NV item
    578           *
    579           * @param   uint8 pData - pointer to the data
    580           *
    581           * @return  None
    582           ***************************************************************************************************/
    583          void MT_SysOsalNVLength(uint8 *pBuf)
    584          {
    585            uint16 nvId;
    586            uint16 nvLen;
    587            uint8 rsp[2];
    588          
    589            /* Skip over RPC header */
    590            pBuf += MT_RPC_FRAME_HDR_SZ;
    591          
    592            /* Get the ID */
    593            nvId = BUILD_UINT16(pBuf[0], pBuf[1]);
    594          
    595            /* Attempt to get NV item length */
    596            nvLen = osal_nv_item_len( nvId );
    597            rsp[0] = LO_UINT16( nvLen );
    598            rsp[1] = HI_UINT16( nvLen );
    599          
    600            /* Build and send back the response */
    601            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    602                                           MT_SYS_OSAL_NV_LENGTH, 2, rsp);
    603          }
    604          
    605          /***************************************************************************************************
    606           * @fn      MT_SysOsalStartTimer
    607           *
    608           * @brief
    609           *
    610           * @param   uint8 pData - pointer to the data
    611           *
    612           * @return  None
    613           ***************************************************************************************************/
    614          void MT_SysOsalStartTimer(uint8 *pBuf)
    615          {
    616            uint16 eventId;
    617            uint8 retValue = ZFailure;
    618            uint8 cmdId;
    619          
    620            /* parse header */
    621            cmdId = pBuf[MT_RPC_POS_CMD1];
    622            pBuf += MT_RPC_FRAME_HDR_SZ;
    623          
    624            if (*pBuf <= 3)
    625            {
    626              eventId = (uint16) MT_SysOsalEventId[*pBuf];
    627              retValue = osal_start_timerEx(MT_TaskID, eventId, BUILD_UINT16(pBuf[1], pBuf[2]));
    628            }
    629            else
    630            {
    631              retValue = ZInvalidParameter;
    632            }
    633          
    634            /* Build and send back the response */
    635            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmdId, 1, &retValue);
    636          }
    637          
    638          /***************************************************************************************************
    639           * @fn      MT_SysOsalStopTimer
    640           *
    641           * @brief
    642           *
    643           * @param   uint8 pData - pointer to the data
    644           *
    645           * @return  None
    646           ***************************************************************************************************/
    647          void MT_SysOsalStopTimer(uint8 *pBuf)
    648          {
    649            uint16 eventId;
    650            uint8 retValue = ZFailure;
    651            uint8 cmdId;
    652          
    653            /* parse header */
    654            cmdId = pBuf[MT_RPC_POS_CMD1];
    655            pBuf += MT_RPC_FRAME_HDR_SZ;
    656          
    657            if (*pBuf <= 3)
    658            {
    659              eventId = (uint16) MT_SysOsalEventId[*pBuf];
    660              retValue = osal_stop_timerEx(MT_TaskID, eventId);
    661            }
    662            else
    663            {
    664              retValue = ZInvalidParameter;
    665            }
    666          
    667            /* Build and send back the response */
    668            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmdId, 1, &retValue );
    669          }
    670          
    671          /***************************************************************************************************
    672           * @fn      MT_SysRandom
    673           *
    674           * @brief
    675           *
    676           * @param   uint8 pData - pointer to the data
    677           *
    678           * @return  None
    679           ***************************************************************************************************/
    680          void MT_SysRandom()
    681          {
    682            uint16 randValue = Onboard_rand();
    683            uint8 retArray[2];
    684          
    685            retArray[0] = LO_UINT16(randValue);
    686            retArray[1] = HI_UINT16(randValue);
    687          
    688            /* Build and send back the response */
    689            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), MT_SYS_RANDOM, 2, retArray );
    690          }
    691          
    692          /***************************************************************************************************
    693           * @fn      MT_SysAdcRead
    694           *
    695           * @brief   Reading ADC value, temperature sensor and voltage
    696           *
    697           * @param   uint8 pData - pointer to the data
    698           *
    699           * @return  None
    700           ***************************************************************************************************/
    701          void MT_SysAdcRead(uint8 *pBuf)
    702          {
    703          #ifndef HAL_BOARD_LM3S
    704            uint8 channel, resolution;
    705            uint16 tempValue;
    706            uint8 retArray[2];
    707            uint8 cmdId;
    708          
    709            /* parse header */
    710            cmdId = pBuf[MT_RPC_POS_CMD1];
    711            pBuf += MT_RPC_FRAME_HDR_SZ;
    712          
    713            /* Channel */
    714            channel = *pBuf++;
    715          
    716            /* Resolution */
    717            resolution = *pBuf++;
    718          
    719            /* Voltage reading */
    720            switch (channel)
    721            {
    722              /* Analog input channel */
    723              case HAL_ADC_CHANNEL_0:
    724              case HAL_ADC_CHANNEL_1:
    725              case HAL_ADC_CHANNEL_2:
    726              case HAL_ADC_CHANNEL_3:
    727              case HAL_ADC_CHANNEL_4:
    728              case HAL_ADC_CHANNEL_5:
    729              case HAL_ADC_CHANNEL_6:
    730              case HAL_ADC_CHANNEL_7:
    731                tempValue = HalAdcRead(channel, resolution);
    732                break;
    733          
    734              /* Temperature sensor */
    735              case(HAL_ADC_CHANNEL_TEMP):
    736                tempValue = HalAdcRead(HAL_ADC_CHANNEL_TEMP, HAL_ADC_RESOLUTION_14);
    737                break;
    738          
    739              /* Voltage reading */
    740              case(HAL_ADC_CHANNEL_VDD):
    741                tempValue = HalAdcRead(HAL_ADC_CHANNEL_VDD, HAL_ADC_RESOLUTION_14);
    742                break;
    743          
    744              /* Undefined channels */
    745              default:
    746                tempValue = 0x00;
    747                break;
    748            }
    749          
    750            retArray[0] = LO_UINT16(tempValue);
    751            retArray[1] = HI_UINT16(tempValue);
    752          
    753            /* Build and send back the response */
    754            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmdId, 2, retArray);
    755          #endif /* #ifndef HAL_BOARD_LM3S */
    756          }
    757          
    758          /**************************************************************************************************
    759           * @fn      MT_SysGpio
    760           *
    761           * @brief   ZAccel RPC interface for controlling the available GPIO pins.
    762           *
    763           * @param   uint8 pData - Pointer to the data.
    764           *
    765           * @return  None
    766           *************************************************************************************************/
    767          void MT_SysGpio(uint8 *pBuf)
    768          {
    769            uint8 cmd, val;
    770            GPIO_Op_t op;
    771          
    772            cmd = pBuf[MT_RPC_POS_CMD1];
    773            pBuf += MT_RPC_FRAME_HDR_SZ;
    774          
    775            op = (GPIO_Op_t)(*pBuf++);
    776            val = *pBuf;
    777          
    778            switch (op)
    779            {
    780              case GPIO_DIR:
    781                if (val & BV(0)) {GPIO_DIR_OUT(0);} else {GPIO_DIR_IN(0);}
    782                if (val & BV(1)) {GPIO_DIR_OUT(1);} else {GPIO_DIR_IN(1);}
    783                if (val & BV(2)) {GPIO_DIR_OUT(2);} else {GPIO_DIR_IN(2);}
    784                if (val & BV(3)) {GPIO_DIR_OUT(3);} else {GPIO_DIR_IN(3);}
    785                break;
    786          
    787              case GPIO_TRI:
    788                if(val & BV(0)) {GPIO_TRI(0);} else if(val & BV(4)) {GPIO_PULL_DN(0);} else {GPIO_PULL_UP(0);}
    789                if(val & BV(1)) {GPIO_TRI(1);} else if(val & BV(5)) {GPIO_PULL_DN(1);} else {GPIO_PULL_UP(1);}
    790                if(val & BV(2)) {GPIO_TRI(2);} else if(val & BV(6)) {GPIO_PULL_DN(2);} else {GPIO_PULL_UP(2);}
    791                if(val & BV(3)) {GPIO_TRI(3);} else if(val & BV(7)) {GPIO_PULL_DN(3);} else {GPIO_PULL_UP(3);}
    792                break;
    793          
    794              case GPIO_SET:
    795                if (val & BV(0)) {GPIO_SET(0);}
    796                if (val & BV(1)) {GPIO_SET(1);}
    797                if (val & BV(2)) {GPIO_SET(2);}
    798                if (val & BV(3)) {GPIO_SET(3);}
    799                break;
    800          
    801              case GPIO_CLR:
    802                if (val & BV(0)) {GPIO_CLR(0);}
    803                if (val & BV(1)) {GPIO_CLR(1);}
    804                if (val & BV(2)) {GPIO_CLR(2);}
    805                if (val & BV(3)) {GPIO_CLR(3);}
    806                break;
    807          
    808              case GPIO_TOG:
    809                if (val & BV(0)) {GPIO_TOG(0);}
    810                if (val & BV(1)) {GPIO_TOG(1);}
    811                if (val & BV(2)) {GPIO_TOG(2);}
    812                if (val & BV(3)) {GPIO_TOG(3);}
    813                break;
    814          
    815              case GPIO_GET:
    816                break;
    817          
    818              case GPIO_HiD:
    819                (val) ? GPIO_HiD_SET() :  GPIO_HiD_CLR();
    820                break;
    821          
    822              default:
    823                break;
    824            }
    825          
    826            val  = (GPIO_GET(0)) ? BV(0) : 0;
    827            val |= (GPIO_GET(1)) ? BV(1) : 0;
    828            val |= (GPIO_GET(2)) ? BV(2) : 0;
    829            val |= (GPIO_GET(3)) ? BV(3) : 0;
    830          
    831            /* Build and send back the response */
    832            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmd, 1, &val);
    833          }
    834          
    835          /**************************************************************************************************
    836           * @fn      MT_SysStackTune
    837           *
    838           * @brief   ZAccel RPC interface for tuning the stack parameters to adjust performance
    839           *
    840           * @param   uint8 pData - Pointer to the data.
    841           *
    842           * @return  None
    843           *************************************************************************************************/
    844          void MT_SysStackTune(uint8 *pBuf)
    845          {
    846            uint8 cmd, rtrn;
    847          
    848            cmd = pBuf[MT_RPC_POS_CMD1];
    849            pBuf += MT_RPC_FRAME_HDR_SZ;
    850          
    851            switch (*pBuf++)
    852            {
    853            case STK_TX_PWR:
    854              rtrn = ZMacSetReq(ZMacPhyTransmitPowerSigned, pBuf);
    855              break;
    856          
    857            case STK_RX_ON_IDLE:
    858              if ((*pBuf != TRUE) && (*pBuf != FALSE))
    859              {
    860                (void)ZMacGetReq(ZMacRxOnIdle, &rtrn);
    861              }
    862              else
    863              {
    864                rtrn = ZMacSetReq(ZMacRxOnIdle, pBuf);
    865              }
    866              break;
    867          
    868            default:
    869              rtrn = ZInvalidParameter;
    870              break;
    871            }
    872          
    873            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS), cmd, 1, &rtrn);
    874          }
    875          
    876          /***************************************************************************************************
    877           * @fn      MT_SysSetUtcTime
    878           *
    879           * @brief   Set the OSAL UTC Time. UTC rollover is: 06:28:16 02/07/2136
    880           *
    881           * @param   pBuf - pointer to time parameters
    882           *
    883           * @return  None
    884           ***************************************************************************************************/
    885          void MT_SysSetUtcTime(uint8 *pBuf)
    886          {
    887            uint8 cmdId;
    888            uint8 retStat;
    889            UTCTime utcSecs;
    890          
    891            /* Parse header */
    892            cmdId = pBuf[MT_RPC_POS_CMD1];
    893            pBuf += MT_RPC_FRAME_HDR_SZ;
    894          
    895            utcSecs = osal_build_uint32( pBuf, 4 );
    896            if ( utcSecs == 0 )
    897            {
    898              UTCTimeStruct utc;
    899          
    900              /* Skip past UTC time */
    901              pBuf += 4;
    902          
    903              /* Get time and date parameters */
    904              utc.hour = *pBuf++;
    905              utc.minutes = *pBuf++;
    906              utc.seconds = *pBuf++;
    907              utc.month = (*pBuf++) - 1;
    908              utc.day = (*pBuf++) - 1;
    909              utc.year = osal_build_uint16 ( pBuf );
    910          
    911              if ((utc.hour < 24) && (utc.minutes < 60) && (utc.seconds < 60) &&
    912                  (utc.month < 12) && (utc.day < 31) && (utc.year > 1999) && (utc.year < 2136))
    913              {
    914                /* Got past the course filter, now check for leap year */
    915                if ((utc.month != 1) || (utc.day < (IsLeapYear( utc.year ) ? 29 : 28)))
    916                {
    917                  /* Numbers look reasonable, convert to UTC */
    918                  utcSecs = osal_ConvertUTCSecs( &utc );
    919                }
    920              }
    921            }
    922          
    923            if ( utcSecs == 0 )
    924            {
    925              /* Bad parameter(s) */
    926              retStat = ZInvalidParameter;
    927            }
    928            else
    929            {
    930              /* Parameters accepted, set the time */
    931              osal_setClock( utcSecs );
    932              retStat = ZSuccess;
    933            }
    934          
    935            /* Build and send back the response */
    936            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    937                                           cmdId, 1, &retStat);
    938          }
    939          
    940          /***************************************************************************************************
    941           * @fn      MT_SysGetUtcTime
    942           *
    943           * @brief   Get the OSAL UTC time
    944           *
    945           * @param   None
    946           *
    947           * @return  32-bit and Parsed UTC time
    948           ***************************************************************************************************/
    949          void MT_SysGetUtcTime(void)
    950          {
    951            uint8 len;
    952            uint8 *buf;
    953          
    954            len = sizeof( UTCTime ) + sizeof( UTCTimeStruct );
    955          
    956            buf = osal_mem_alloc( len );
    957            if ( buf )
    958            {
    959              uint8 *pBuf;
    960              UTCTime utcSecs;
    961              UTCTimeStruct utcTime;
    962          
    963              // Get current 32-bit UTC time and parse it
    964              utcSecs = osal_getClock();
    965              osal_ConvertUTCTime( &utcTime, utcSecs );
    966          
    967              // Start with 32-bit UTC time
    968              pBuf = osal_buffer_uint32( buf, utcSecs );
    969          
    970              // Concatenate parsed UTC time fields
    971              *pBuf++ = utcTime.hour;
    972              *pBuf++ = utcTime.minutes;
    973              *pBuf++ = utcTime.seconds;
    974              *pBuf++ = utcTime.month + 1;  // Convert to human numbers
    975              *pBuf++ = utcTime.day + 1;
    976              *pBuf++ = LO_UINT16( utcTime.year );
    977              *pBuf++ = HI_UINT16( utcTime.year );
    978          
    979              /* Build and send back the response */
    980              MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_SRSP | (uint8)MT_RPC_SYS_SYS),
    981                                             MT_SYS_GET_TIME, (uint8)(pBuf-buf), buf);
    982          
    983              osal_mem_free( buf );
    984            }
    985          }
    986          #endif /* MT_SYS_FUNC */
    987          
    988          /***************************************************************************************************
    989           * SUPPORT
    990           ***************************************************************************************************/
    991          
    992          /***************************************************************************************************
    993           * @fn      MT_SysResetInd()
    994           *
    995           * @brief   Sends a ZTOOL "reset response" message.
    996           *
    997           * @param   None
    998           *
    999           * @return  None
   1000           *
   1001           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1002          void MT_SysResetInd(void)
   \                     MT_SysResetInd:
   1003          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000                REQUIRE ?V2
   \   000000   74F5         MOV       A,#-0xb
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 6
   \   000005   74FA         MOV       A,#-0x6
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   1004            uint8 retArray[6];
   1005          
   1006            retArray[0] = ResetReason();   /* Reason */
   \   00000A   E59D         MOV       A,0x9d
   \   00000C   13           RRC       A
   \   00000D   13           RRC       A
   \   00000E   13           RRC       A
   \   00000F   541F         ANL       A,#0x1f
   \   000011   5403         ANL       A,#0x3
   \   000013   85..82       MOV       DPL,?XSP + 0
   \   000016   85..83       MOV       DPH,?XSP + 1
   \   000019   F0           MOVX      @DPTR,A
   1007            osal_memcpy( &retArray[1], MTVersionString, 5 );   /* Revision info */
   \   00001A                ; Setup parameters for call to function osal_memcpy
   \   00001A   75....       MOV       ?V0,#MTVersionString & 0xff
   \   00001D   75....       MOV       ?V1,#(MTVersionString >> 8) & 0xff
   \   000020   75..00       MOV       ?V2,#0x0
   \   000023   78..         MOV       R0,#?V0
   \   000025   12....       LCALL     ?PUSH_XSTACK_I_THREE
   \   000028   7C05         MOV       R4,#0x5
   \   00002A   7D00         MOV       R5,#0x0
   \   00002C   7404         MOV       A,#0x4
   \   00002E   12....       LCALL     ?XSTACK_DISP0_8
   \   000031   AA82         MOV       R2,DPL
   \   000033   AB83         MOV       R3,DPH
   \   000035   12....       LCALL     `??osal_memcpy::?relay`; Banked call to: osal_memcpy
   \   000038   7403         MOV       A,#0x3
   \   00003A   12....       LCALL     ?DEALLOC_XSTACK8
   1008          
   1009            /* Send out Reset Response message */
   1010            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_SYS), MT_SYS_RESET_IND,
   1011                                          sizeof(retArray), retArray);
   \   00003D                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   00003D   AC..         MOV       R4,?XSP + 0
   \   00003F   AD..         MOV       R5,?XSP + 1
   \   000041   7B06         MOV       R3,#0x6
   \   000043   7A80         MOV       R2,#-0x80
   \   000045   7941         MOV       R1,#0x41
   \   000047   12....       LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   1012          }
   \   00004A   7406         MOV       A,#0x6
   \   00004C   12....       LCALL     ?DEALLOC_XSTACK8
   \   00004F   7F03         MOV       R7,#0x3
   \   000051   02....       LJMP      ?BANKED_LEAVE_XDATA
   \   000054                REQUIRE SLEEPSTA
   1013          
   1014          /***************************************************************************************************
   1015           * @fn      MT_SysOsalTimerExpired()
   1016           *
   1017           * @brief   Sends a SYS Osal Timer Expired
   1018           *
   1019           * @param   None
   1020           *
   1021           * @return  None
   1022           *
   1023           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1024          void MT_SysOsalTimerExpired(uint8 Id)
   \                     MT_SysOsalTimerExpired:
   1025          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   1026            uint8 retValue;
   1027            retValue = Id;
   \   00000B   85..82       MOV       DPL,?XSP + 0
   \   00000E   85..83       MOV       DPH,?XSP + 1
   \   000011   F0           MOVX      @DPTR,A
   1028            MT_BuildAndSendZToolResponse(((uint8)MT_RPC_CMD_AREQ | (uint8)MT_RPC_SYS_SYS), MT_SYS_OSAL_TIMER_EXPIRED, 1, &retValue);
   \   000012                ; Setup parameters for call to function MT_BuildAndSendZToolResponse
   \   000012   AC..         MOV       R4,?XSP + 0
   \   000014   AD..         MOV       R5,?XSP + 1
   \   000016   7B01         MOV       R3,#0x1
   \   000018   7A81         MOV       R2,#-0x7f
   \   00001A   7941         MOV       R1,#0x41
   \   00001C   12....       LCALL     `??MT_BuildAndSendZToolResponse::?relay`; Banked call to: MT_BuildAndSendZToolResponse
   1029          }
   \   00001F   7401         MOV       A,#0x1
   \   000021   12....       LCALL     ?DEALLOC_XSTACK8
   \   000024   7F01         MOV       R7,#0x1
   \   000026   02....       LJMP      ?BANKED_LEAVE_XDATA
   1030          
   1031          /***************************************************************************************************
   1032           ***************************************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      1     10   MT_SysOsalTimerExpired
        0     10   -> MT_BuildAndSendZToolResponse
      1     20   MT_SysResetInd
        0     17   -> MT_BuildAndSendZToolResponse
        0     20   -> osal_memcpy


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       8  MT_SysOsalEventId
      41  MT_SysOsalTimerExpired
      84  MT_SysResetInd
       1  SLEEPSTA
      12  -- Other

 
 125 bytes in segment BANKED_CODE
  12 bytes in segment BANK_RELAYS
   1 byte  in segment SFR_AN
   8 bytes in segment XDATA_ROM_C
 
  12 bytes of CODE     memory
   8 bytes of CONST    memory
   0 bytes of DATA     memory (+ 1 byte shared)
 125 bytes of HUGECODE memory

Errors: none
Warnings: none
