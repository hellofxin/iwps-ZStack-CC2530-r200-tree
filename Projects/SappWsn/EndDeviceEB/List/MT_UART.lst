###############################################################################
#
# IAR C/C++ Compiler V10.30.1.6000 for 8051               15/Sep/2019  14:22:31
# Copyright 2004-2018 IAR Systems AB.
# PC-locked license - IAR Embedded Workbench for 8051
#
#    Core               =  plain
#    Code model         =  banked
#    Data model         =  large
#    Calling convention =  xdata reentrant
#    Constant location  =  data_rom
#    Dptr setup         =  1,16
#                          
#    Source file        =  
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Components\mt\MT_UART.c
#    Command line       =  
#        -f C:\Users\ãÆË¸\AppData\Local\Temp\EW1386.tmp
#        (F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Components\mt\MT_UART.c -D
#        NWK_AUTO_POLL -D ZTOOL_P1 -D xMT_TASK -D xMT_SYS_FUNC -D MT_ZDO_FUNC
#        -D SAPP_ZSTACK -lC
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List
#        -lA
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List
#        --diag_suppress Pe001,Pa010 -o
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\Obj
#        -e --debug --core=plain --dptr=16,1 --data_model=large
#        --code_model=banked --calling_convention=xdata_reentrant
#        --place_constants=data_rom --nr_virtual_regs 8 -f
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wEndev.cfg
#        (-DCPU32MHZ -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3
#        -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\Tools\CC2530DB\f8wConfig.cfg
#        (-DZIGBEEPRO -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR
#        -DDEFAULT_CHANLIST=0x00000800 -DZDAPP_CONFIG_PAN_ID=0x4095
#        -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MASK=0x007F
#        -DBEACON_REQUEST_DELAY=100 -DBEACON_REQ_DELAY_MASK=0x00FF
#        -DLINK_STATUS_JITTER_MASK=0x007F -DROUTE_EXPIRY_TIME=30
#        -DAPSC_ACK_WAIT_DURATION_POLLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7
#        -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3
#        -DNWK_MAX_DATA_RETRIES=2 -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9
#        -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40 -DNWK_MAX_BINDING_ENTRIES=4
#        -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01, 0x03, 0x05, 0x07,
#        0x09, 0x0B, 0x0D, 0x0F, 0x00, 0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C,
#        0x0D}" -DMAC_MAX_FRAME_SIZE=116 -DZDNWKMGR_MIN_TRANSMISSIONS=20
#        "-DCONST=const __code" -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE
#        -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100
#        -DREJOIN_POLL_RATE=440) -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\ -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\Source\ -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\zstack\ZMain\TI2530DB\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\hal\include\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\hal\target\CC2530EB\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\include\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\high_level\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\low_level\srf04\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mac\low_level\srf04\single_chip\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\mt\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\osal\include\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\services\saddr\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\services\sdata\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\af\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\nwk\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sapi\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sec\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\sys\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\stack\zdo\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\zmac\
#        -I
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\..\..\Components\zmac\f8w\
#        -Ohz --require_prototypes --no_code_motion)
#    Locale             =  Chinese (Simplified)_CHN.936
#    List file          =  
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\List\MT_UART.lst
#    Object file        =  
#        F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Projects\SappWsn\EndDeviceEB\Obj\MT_UART.r51
#
###############################################################################

F:\Zigbee\zigbee\ZStack-CC2530-r200-tree\Components\mt\MT_UART.c
      1          /***************************************************************************************************
      2            Filename:       MT_UART.c
      3            Revised:        $Date: 2009-03-12 16:25:22 -0700 (Thu, 12 Mar 2009) $
      4            Revision:       $Revision: 19404 $
      5          
      6            Description:  This module handles anything dealing with the serial port.
      7          
      8            Copyright 2007 Texas Instruments Incorporated. All rights reserved.
      9          
     10            IMPORTANT: Your use of this Software is limited to those specific rights
     11            granted under the terms of a software license agreement between the user
     12            who downloaded the software, his/her employer (which must be your employer)
     13            and Texas Instruments Incorporated (the "License").  You may not use this
     14            Software unless you agree to abide by the terms of the License. The License
     15            limits your use, and you acknowledge, that the Software may not be modified,
     16            copied or distributed unless embedded on a Texas Instruments microcontroller
     17            or used solely and exclusively in conjunction with a Texas Instruments radio
     18            frequency transceiver, which is integrated into your product.  Other than for
     19            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     20            works of, modify, distribute, perform, display or sell this Software and/or
     21            its documentation for any purpose.
     22          
     23            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     24            PROVIDED “AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     25            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     26            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     27            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     28            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     29            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     30            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     31            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     32            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     33            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     34          
     35            Should you have any questions regarding your right to use this Software,
     36            contact Texas Instruments Incorporated at www.TI.com.
     37          
     38          ***************************************************************************************************/
     39          
     40          /***************************************************************************************************
     41           * INCLUDES
     42           ***************************************************************************************************/
     43          #include "ZComDef.h"
     44          #include "OSAL.h"
     45          #include "hal_uart.h"
     46          #include "MT.h"
     47          #include "MT_UART.h"
     48          #include "OSAL_Memory.h"
     49          
     50          
     51          /***************************************************************************************************
     52           * MACROS
     53           ***************************************************************************************************/
     54          
     55          /***************************************************************************************************
     56           * CONSTANTS
     57           ***************************************************************************************************/
     58          /* State values for ZTool protocal */
     59          #define SOP_STATE      0x00
     60          #define LEN_STATE      0x01
     61          #define DATA_STATE     0x02
     62          #define FCS_STATE      0x03
     63          
     64          /***************************************************************************************************
     65           *                                         GLOBAL VARIABLES
     66           ***************************************************************************************************/
     67          /* Used to indentify the application ID for osal task */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     68          uint8 App_TaskID;
   \                     App_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     69          
     70          /* ZTool protocal parameters */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     71          uint8 state = SOP_STATE;
   \                     state:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     72          mtOSALSerialData_t  *pMsg;
   \                     pMsg:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     73          mtUserSerialMsg_t   *pMsgContent;
   \                     pMsgContent:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     74          uint8  tempDataLen;
   \                     tempDataLen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     75          
     76          #if defined (ZAPP_P1) || defined (ZAPP_P2)
     77          uint16  MT_UartMaxZAppBufLen;
     78          bool    MT_UartZAppRxStatus;
     79          #endif
     80          
     81          
     82          /***************************************************************************************************
     83           *                                          LOCAL FUNCTIONS
     84           ***************************************************************************************************/
     85          
     86          /***************************************************************************************************
     87           * @fn      MT_UartInit
     88           *
     89           * @brief   Initialize MT with UART support
     90           *
     91           * @param   None
     92           *
     93           * @return  None
     94          ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
     95          void MT_UartInit ()
   \                     MT_UartInit:
     96          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 29
   \   000004   74E3         MOV       A,#-0x1d
   \   000006   12....       LCALL     ?ALLOC_XSTACK8
     97            halUARTCfg_t uartConfig;
     98          
     99            /* Initialize APP ID */
    100            App_TaskID = 0;
   \   000009   90....       MOV       DPTR,#App_TaskID
   \   00000C   E4           CLR       A
   \   00000D   F0           MOVX      @DPTR,A
    101          
    102            /* UART Configuration */
    103            uartConfig.configured           = TRUE;
   \   00000E   85..82       MOV       DPL,?XSP + 0
   \   000011   85..83       MOV       DPH,?XSP + 1
   \   000014   04           INC       A
   \   000015   F0           MOVX      @DPTR,A
    104            uartConfig.baudRate             = MT_UART_DEFAULT_BAUDRATE;
   \   000016   12....       LCALL     ?XSTACK_DISP0_8
   \   000019   7404         MOV       A,#0x4
   \   00001B   F0           MOVX      @DPTR,A
    105            uartConfig.flowControl          = MT_UART_DEFAULT_OVERFLOW;
   \   00001C   7402         MOV       A,#0x2
   \   00001E   12....       LCALL     ?XSTACK_DISP0_8
   \   000021   E4           CLR       A
   \   000022   F0           MOVX      @DPTR,A
    106            uartConfig.flowControlThreshold = MT_UART_DEFAULT_THRESHOLD;
   \   000023   7403         MOV       A,#0x3
   \   000025   12....       LCALL     ?XSTACK_DISP0_8
   \   000028   7440         MOV       A,#0x40
   \   00002A   F0           MOVX      @DPTR,A
   \   00002B   A3           INC       DPTR
   \   00002C   E4           CLR       A
   \   00002D   F0           MOVX      @DPTR,A
    107            uartConfig.rx.maxBufSize        = MT_UART_DEFAULT_MAX_RX_BUFF;
   \   00002E   740A         MOV       A,#0xa
   \   000030   12....       LCALL     ?XSTACK_DISP0_8
   \   000033   7480         MOV       A,#-0x80
   \   000035   F0           MOVX      @DPTR,A
   \   000036   A3           INC       DPTR
   \   000037   E4           CLR       A
   \   000038   F0           MOVX      @DPTR,A
    108            uartConfig.tx.maxBufSize        = MT_UART_DEFAULT_MAX_TX_BUFF;
   \   000039   7412         MOV       A,#0x12
   \   00003B   12....       LCALL     ?XSTACK_DISP0_8
   \   00003E   7480         MOV       A,#-0x80
   \   000040   F0           MOVX      @DPTR,A
   \   000041   A3           INC       DPTR
   \   000042   E4           CLR       A
   \   000043   F0           MOVX      @DPTR,A
    109            uartConfig.idleTimeout          = MT_UART_DEFAULT_IDLE_TIMEOUT;
   \   000044   7405         MOV       A,#0x5
   \   000046   12....       LCALL     ?XSTACK_DISP0_8
   \   000049   7406         MOV       A,#0x6
   \   00004B   F0           MOVX      @DPTR,A
    110            uartConfig.intEnable            = TRUE;
   \   00004C   7416         MOV       A,#0x16
   \   00004E   12....       LCALL     ?XSTACK_DISP0_8
   \   000051   7401         MOV       A,#0x1
   \   000053   F0           MOVX      @DPTR,A
    111          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    112            uartConfig.callBackFunc         = MT_UartProcessZToolData;
   \   000054   741B         MOV       A,#0x1b
   \   000056   12....       LCALL     ?XSTACK_DISP0_8
   \   000059   74..         MOV       A,#`??MT_UartProcessZToolData::?relay` & 0xff
   \   00005B   F0           MOVX      @DPTR,A
   \   00005C   A3           INC       DPTR
   \   00005D   74..         MOV       A,#(`??MT_UartProcessZToolData::?relay` >> 8) & 0xff
   \   00005F   F0           MOVX      @DPTR,A
    113          #elif defined (ZAPP_P1) || defined (ZAPP_P2)
    114            uartConfig.callBackFunc         = MT_UartProcessZAppData;
    115          #else
    116            uartConfig.callBackFunc         = NULL;
    117          #endif
    118          
    119            /* Start UART */
    120          #if defined (MT_UART_DEFAULT_PORT)
    121            HalUARTOpen (MT_UART_DEFAULT_PORT, &uartConfig);
   \   000060                ; Setup parameters for call to function HalUARTOpen
   \   000060   AA..         MOV       R2,?XSP + 0
   \   000062   AB..         MOV       R3,?XSP + 1
   \   000064   7900         MOV       R1,#0x0
   \   000066   12....       LCALL     `??HalUARTOpen::?relay`; Banked call to: HalUARTOpen
    122          #else
    123            /* Silence IAR compiler warning */
    124            (void)uartConfig;
    125          #endif
    126          
    127            /* Initialize for ZApp */
    128          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    129            /* Default max bytes that ZAPP can take */
    130            MT_UartMaxZAppBufLen  = 1;
    131            MT_UartZAppRxStatus   = MT_UART_ZAPP_RX_READY;
    132          #endif
    133          
    134          }
   \   000069   741D         MOV       A,#0x1d
   \   00006B   12....       LCALL     ?DEALLOC_XSTACK8
   \   00006E                REQUIRE ?Subroutine0
   \   00006E                ; // Fall through to label ?Subroutine0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   D083         POP       DPH
   \   000002   D082         POP       DPL
   \   000004   02....       LJMP      ?BRET
    135          
    136          /***************************************************************************************************
    137           * @fn      MT_SerialRegisterTaskID
    138           *
    139           * @brief   This function registers the taskID of the application so it knows
    140           *          where to send the messages whent they come in.
    141           *
    142           * @param   void
    143           *
    144           * @return  void
    145           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    146          void MT_UartRegisterTaskID( byte taskID )
   \                     MT_UartRegisterTaskID:
    147          {
   \   000000   C082         PUSH      DPL
   \   000002   C083         PUSH      DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    148            App_TaskID = taskID;
   \   000004   E9           MOV       A,R1
   \   000005   90....       MOV       DPTR,#App_TaskID
   \   000008   F0           MOVX      @DPTR,A
    149          }
   \   000009   80..         SJMP      ?Subroutine0
    150          
    151          /***************************************************************************************************
    152           * @fn      SPIMgr_CalcFCS
    153           *
    154           * @brief   Calculate the FCS of a message buffer by XOR'ing each byte.
    155           *          Remember to NOT include SOP and FCS fields, so start at the CMD field.
    156           *
    157           * @param   byte *msg_ptr - message pointer
    158           * @param   byte len - length (in bytes) of message
    159           *
    160           * @return  result byte
    161           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    162          byte MT_UartCalcFCS(uint8 lastResult, uint8 *msg_ptr, uint8 len )
   \                     MT_UartCalcFCS:
    163          {
   \   000000   74F7         MOV       A,#-0x9
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    164            uint8 x;
    165            uint8 xorResult = lastResult;
    166          
    167            for ( x = 0; x < len; x++, msg_ptr++ )
   \   000005   7800         MOV       R0,#0x0
   \   000007   800E         SJMP      ??MT_UartCalcFCS_0
    168              xorResult = xorResult ^ *msg_ptr;
   \                     ??MT_UartCalcFCS_1:
   \   000009   8A82         MOV       DPL,R2
   \   00000B   8B83         MOV       DPH,R3
   \   00000D   E0           MOVX      A,@DPTR
   \   00000E   C9           XCH       A,R1
   \   00000F   69           XRL       A,R1
   \   000010   F9           MOV       R1,A
   \   000011   08           INC       R0
   \   000012   A3           INC       DPTR
   \   000013   AA82         MOV       R2,DPL
   \   000015   AB83         MOV       R3,DPH
   \                     ??MT_UartCalcFCS_0:
   \   000017   E8           MOV       A,R0
   \   000018   C3           CLR       C
   \   000019   9C           SUBB      A,R4
   \   00001A   40ED         JC        ??MT_UartCalcFCS_1
    169          
    170            return ( xorResult );
   \   00001C   7F01         MOV       R7,#0x1
   \   00001E   02....       LJMP      ?BANKED_LEAVE_XDATA
    171          }
    172          
    173          #if defined (ZTOOL_P1) || defined (ZTOOL_P2)
    174          /***************************************************************************************************
    175           * @fn      MT_UartProcessZToolData
    176           *
    177           * @brief   | SOP | CMD |Data Length| cmdEP | Address | EndPoint |  Data  | FSC |
    178           *          |  1  |  2  |    1      |   2   |    2    |     1    | 1 ~119 |  1  |
    179           *
    180           *          Parses the data and determine either is SPI or just simply serial data
    181           *          then send the data to correct place (MT or APP)
    182           *
    183           * @param   port     - UART port
    184           *          event    - Event that causes the callback
    185           *
    186           *
    187           * @return  None
    188           ***************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    189          void MT_UartProcessZToolData ( uint8 port, uint8 event )
   \                     MT_UartProcessZToolData:
    190          {
   \   000000                REQUIRE ?V0
   \   000000                REQUIRE ?V1
   \   000000   74F6         MOV       A,#-0xa
   \   000002   12....       LCALL     ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV       A,#-0x1
   \   000007   12....       LCALL     ?ALLOC_XSTACK8
   \   00000A   E9           MOV       A,R1
   \   00000B   FE           MOV       R6,A
    191              uint8  ch;
    192              uint8  bytesInRxBuffer;
    193          
    194              (void)event;  // Intentionally unreferenced parameter
   \   00000C   8046         SJMP      ??MT_UartProcessZToolData_0
    195          
    196              while (Hal_UART_RxBufLen(port))
    197              {
    198                  HalUARTRead (port, &ch, 1);
    199          
    200                  switch(state)
    201                  {
    202                  case SOP_STATE:
    203                      if(ch == MT_UART_SOF)
    204                          state = LEN_STATE;
    205                      break;
    206                  case LEN_STATE:
    207                      if(ch < 7)
    208                      {
    209                          // invalid length field
    210                          state = SOP_STATE;
    211                          break;
    212                      }
    213                      pMsg = (mtOSALSerialData_t *)osal_msg_allocate(sizeof(mtOSALSerialData_t) +
    214                                                                     ch + 3);//SOP+LEN+FSC
    215                      tempDataLen = 0;
    216                      /* Allocate memory for the data */
    217          //            pMsg = (mtOSALSerialData_t *)osal_msg_allocate(sizeof(mtOSALSerialData_t) + sizeof(mtUserSerialMsg_t) +
    218          //                                                           ch - 5);
    219                      if (pMsg)
    220                      {
    221                          /* Fill up what we can */
    222                          pMsg->hdr.event = CMD_SERIAL_MSG;
   \                     ??MT_UartProcessZToolData_1:
   \   00000E   E0           MOVX      A,@DPTR
   \   00000F   F583         MOV       DPH,A
   \   000011   8A82         MOV       DPL,R2
   \   000013   7401         MOV       A,#0x1
   \   000015   F0           MOVX      @DPTR,A
    223                          pMsg->msg = (uint8*)(pMsg + 1);
   \   000016   90....       MOV       DPTR,#pMsg
   \   000019   E0           MOVX      A,@DPTR
   \   00001A   2404         ADD       A,#0x4
   \   00001C   F8           MOV       R0,A
   \   00001D   A3           INC       DPTR
   \   00001E   E0           MOVX      A,@DPTR
   \   00001F   3400         ADDC      A,#0x0
   \   000021   F9           MOV       R1,A
   \   000022   90....       MOV       DPTR,#pMsg
   \   000025   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_4:
   \   000028   E8           MOV       A,R0
   \   000029   F0           MOVX      @DPTR,A
   \   00002A   A3           INC       DPTR
   \   00002B   E9           MOV       A,R1
   \   00002C   F0           MOVX      @DPTR,A
    224                          pMsgContent = (mtUserSerialMsg_t *)pMsg->msg;
   \   00002D   90....       MOV       DPTR,#pMsgContent
   \   000030   E8           MOV       A,R0
   \   000031   F0           MOVX      @DPTR,A
   \   000032   A3           INC       DPTR
   \   000033   E9           MOV       A,R1
   \   000034   F0           MOVX      @DPTR,A
    225                          pMsgContent->sop = MT_UART_SOF;
   \   000035   F583         MOV       DPH,A
   \   000037   8882         MOV       DPL,R0
   \   000039   A3           INC       DPTR
   \   00003A   7402         MOV       A,#0x2
   \   00003C   F0           MOVX      @DPTR,A
    226                          pMsgContent->len = ch;
   \   00003D   85..82       MOV       DPL,?XSP + 0
   \   000040   85..83       MOV       DPH,?XSP + 1
   \   000043   E0           MOVX      A,@DPTR
   \   000044   C0E0         PUSH      A
   \   000046   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000049   A3           INC       DPTR
   \   00004A   A3           INC       DPTR
   \   00004B   D0E0         POP       A
   \   00004D   F0           MOVX      @DPTR,A
    227                          state = DATA_STATE;
   \   00004E   90....       MOV       DPTR,#state
   \   000051   7402         MOV       A,#0x2
   \                     ??MT_UartProcessZToolData_2:
   \   000053   F0           MOVX      @DPTR,A
    228                      }
    229                      else
    230                      {
    231                          pMsgContent = NULL;
    232                          state = SOP_STATE;
    233                          return;
    234                      }
    235                      break;
   \                     ??MT_UartProcessZToolData_0:
   \   000054                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   000054   EE           MOV       A,R6
   \   000055   F9           MOV       R1,A
   \   000056   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   000059   EA           MOV       A,R2
   \   00005A   4B           ORL       A,R3
   \   00005B   7003         JNZ       $+5
   \   00005D   02....       LJMP      ??MT_UartProcessZToolData_3 & 0xFFFF
   \   000060                ; Setup parameters for call to function HalUARTRead
   \   000060   7C01         MOV       R4,#0x1
   \   000062   7D00         MOV       R5,#0x0
   \   000064   AA..         MOV       R2,?XSP + 0
   \   000066   AB..         MOV       R3,?XSP + 1
   \   000068   EE           MOV       A,R6
   \   000069   F9           MOV       R1,A
   \   00006A   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   00006D   90....       MOV       DPTR,#state
   \   000070   E0           MOVX      A,@DPTR
   \   000071   600E         JZ        ??MT_UartProcessZToolData_4
   \   000073   14           DEC       A
   \   000074   601D         JZ        ??MT_UartProcessZToolData_5
   \   000076   14           DEC       A
   \   000077   605B         JZ        ??MT_UartProcessZToolData_6
   \   000079   14           DEC       A
   \   00007A   7003         JNZ       $+5
   \   00007C   02....       LJMP      ??MT_UartProcessZToolData_7 & 0xFFFF
   \   00007F   80D3         SJMP      ??MT_UartProcessZToolData_0
   \                     ??MT_UartProcessZToolData_4:
   \   000081   85..82       MOV       DPL,?XSP + 0
   \   000084   85..83       MOV       DPH,?XSP + 1
   \   000087   E0           MOVX      A,@DPTR
   \   000088   6402         XRL       A,#0x2
   \   00008A   70C8         JNZ       ??MT_UartProcessZToolData_0
   \   00008C   90....       MOV       DPTR,#state
   \   00008F   7401         MOV       A,#0x1
   \   000091   80C0         SJMP      ??MT_UartProcessZToolData_2
   \                     ??MT_UartProcessZToolData_5:
   \   000093   85..82       MOV       DPL,?XSP + 0
   \   000096   85..83       MOV       DPH,?XSP + 1
   \   000099   E0           MOVX      A,@DPTR
   \   00009A   C3           CLR       C
   \   00009B   9407         SUBB      A,#0x7
   \   00009D   5003         JNC       $+5
   \   00009F   02....       LJMP      ??MT_UartProcessZToolData_8 & 0xFFFF
   \   0000A2                ; Setup parameters for call to function osal_msg_allocate
   \   0000A2   E0           MOVX      A,@DPTR
   \   0000A3   2407         ADD       A,#0x7
   \   0000A5   FA           MOV       R2,A
   \   0000A6   E4           CLR       A
   \   0000A7   3400         ADDC      A,#0x0
   \   0000A9   FB           MOV       R3,A
   \   0000AA   12....       LCALL     `??osal_msg_allocate::?relay`; Banked call to: osal_msg_allocate
   \   0000AD   90....       MOV       DPTR,#pMsg
   \   0000B0   EA           MOV       A,R2
   \   0000B1   F0           MOVX      @DPTR,A
   \   0000B2   A3           INC       DPTR
   \   0000B3   EB           MOV       A,R3
   \   0000B4   F0           MOVX      @DPTR,A
   \   0000B5   90....       MOV       DPTR,#tempDataLen
   \   0000B8   E4           CLR       A
   \   0000B9   F0           MOVX      @DPTR,A
   \   0000BA   90....       MOV       DPTR,#pMsg + 1
   \   0000BD   E0           MOVX      A,@DPTR
   \   0000BE   F9           MOV       R1,A
   \   0000BF   EA           MOV       A,R2
   \   0000C0   49           ORL       A,R1
   \   0000C1   6003         JZ        $+5
   \   0000C3   02....       LJMP      ??MT_UartProcessZToolData_1 & 0xFFFF
   \   0000C6   90....       MOV       DPTR,#pMsgContent
   \   0000C9   E4           CLR       A
   \   0000CA   F0           MOVX      @DPTR,A
   \   0000CB   A3           INC       DPTR
   \   0000CC   F0           MOVX      @DPTR,A
   \   0000CD   90....       MOV       DPTR,#state
   \   0000D0   F0           MOVX      @DPTR,A
   \   0000D1   02....       LJMP      ??MT_UartProcessZToolData_3 & 0xFFFF
    236                  case DATA_STATE:
    237                      pMsgContent->dataBody[tempDataLen++] = ch;
   \                     ??MT_UartProcessZToolData_6:
   \   0000D4   85..82       MOV       DPL,?XSP + 0
   \   0000D7   85..83       MOV       DPH,?XSP + 1
   \   0000DA   E0           MOVX      A,@DPTR
   \   0000DB   C0E0         PUSH      A
   \   0000DD   90....       MOV       DPTR,#tempDataLen
   \   0000E0   E0           MOVX      A,@DPTR
   \   0000E1   F8           MOV       R0,A
   \   0000E2   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   0000E5   D0E0         POP       A
   \   0000E7   F0           MOVX      @DPTR,A
   \   0000E8   90....       MOV       DPTR,#tempDataLen
   \   0000EB   E0           MOVX      A,@DPTR
   \   0000EC   04           INC       A
   \   0000ED   F0           MOVX      @DPTR,A
    238                      /* Check number of bytes left in the Rx buffer */
    239                      bytesInRxBuffer = Hal_UART_RxBufLen(port);
   \   0000EE                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   0000EE   EE           MOV       A,R6
   \   0000EF   F9           MOV       R1,A
   \   0000F0   12....       LCALL     `??Hal_UART_RxBufLen::?relay`; Banked call to: Hal_UART_RxBufLen
   \   0000F3   EA           MOV       A,R2
   \   0000F4   FF           MOV       R7,A
    240          
    241                      /* If the remain of the data is there, read them all, otherwise, just read enough */
    242                      if (bytesInRxBuffer <= pMsgContent->len - tempDataLen)
   \   0000F5   12....       LCALL     ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   0000F8   F8           MOV       R0,A
   \   0000F9   90....       MOV       DPTR,#tempDataLen
   \   0000FC   E0           MOVX      A,@DPTR
   \   0000FD   FA           MOV       R2,A
   \   0000FE   E8           MOV       A,R0
   \   0000FF   C3           CLR       C
   \   000100   9A           SUBB      A,R2
   \   000101   F8           MOV       R0,A
   \   000102   95E0         SUBB      A,0xE0 /* A   */
   \   000104   F9           MOV       R1,A
   \   000105   EF           MOV       A,R7
   \   000106   FA           MOV       R2,A
   \   000107   C3           CLR       C
   \   000108   E8           MOV       A,R0
   \   000109   9A           SUBB      A,R2
   \   00010A   E9           MOV       A,R1
   \   00010B   9400         SUBB      A,#0x0
   \   00010D   A2D2         MOV       C,0xD0 /* PSW */.2
   \   00010F   65D0         XRL       A,PSW
   \   000111   33           RLC       A
   \   000112   4010         JC        ??MT_UartProcessZToolData_9
    243                      {
    244                          HalUARTRead (port, &pMsgContent->dataBody[tempDataLen], bytesInRxBuffer);
   \   000114                ; Setup parameters for call to function HalUARTRead
   \   000114   EF           MOV       A,R7
   \   000115   FC           MOV       R4,A
   \   000116   7D00         MOV       R5,#0x0
   \   000118   E0           MOVX      A,@DPTR
   \   000119   F8           MOV       R0,A
   \   00011A   12....       LCALL     ?Subroutine1 & 0xFFFF
    245                          tempDataLen += bytesInRxBuffer;
   \                     ??CrossCallReturnLabel_0:
   \   00011D   90....       MOV       DPTR,#tempDataLen
   \   000120   E0           MOVX      A,@DPTR
   \   000121   2F           ADD       A,R7
   \   000122   8018         SJMP      ??MT_UartProcessZToolData_10
    246                      }
    247                      else
    248                      {
    249                          HalUARTRead (port, &pMsgContent->dataBody[tempDataLen], pMsgContent->len - tempDataLen);
   \                     ??MT_UartProcessZToolData_9:
   \   000124   E0           MOVX      A,@DPTR
   \   000125   F8           MOV       R0,A
   \   000126                ; Setup parameters for call to function HalUARTRead
   \   000126   90....       MOV       DPTR,#pMsgContent
   \   000129   12....       LCALL     ?Subroutine3 & 0xFFFF
   \                     ??CrossCallReturnLabel_5:
   \   00012C   E0           MOVX      A,@DPTR
   \   00012D   C3           CLR       C
   \   00012E   98           SUBB      A,R0
   \   00012F   FC           MOV       R4,A
   \   000130   95E0         SUBB      A,0xE0 /* A   */
   \   000132   FD           MOV       R5,A
   \   000133   12....       LCALL     ?Subroutine1 & 0xFFFF
    250                          tempDataLen += (pMsgContent->len - tempDataLen);
   \                     ??CrossCallReturnLabel_1:
   \   000136   12....       LCALL     ?Subroutine2 & 0xFFFF
    251                      }
   \                     ??CrossCallReturnLabel_3:
   \   000139   90....       MOV       DPTR,#tempDataLen
   \                     ??MT_UartProcessZToolData_10:
   \   00013C   F0           MOVX      @DPTR,A
    252                      /* If number of bytes read is equal to data length, time to move on to FCS */
    253                      if ( tempDataLen == pMsgContent->len )
   \   00013D   E0           MOVX      A,@DPTR
   \   00013E   F8           MOV       R0,A
   \   00013F   90....       MOV       DPTR,#pMsgContent
   \   000142   E0           MOVX      A,@DPTR
   \   000143   F9           MOV       R1,A
   \   000144   A3           INC       DPTR
   \   000145   E0           MOVX      A,@DPTR
   \   000146   F583         MOV       DPH,A
   \   000148   8982         MOV       DPL,R1
   \   00014A   A3           INC       DPTR
   \   00014B   A3           INC       DPTR
   \   00014C   E0           MOVX      A,@DPTR
   \   00014D   68           XRL       A,R0
   \   00014E   6003         JZ        $+5
   \   000150   02....       LJMP      ??MT_UartProcessZToolData_0 & 0xFFFF
    254                          state = FCS_STATE;
   \   000153   90....       MOV       DPTR,#state
   \   000156   7403         MOV       A,#0x3
   \   000158   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    255                      break;
    256                  case FCS_STATE:
    257                      /* Make sure it's correct */
    258                      {
    259                          pMsgContent->fsc = ch;
   \                     ??MT_UartProcessZToolData_7:
   \   00015B   85..82       MOV       DPL,?XSP + 0
   \   00015E   85..83       MOV       DPH,?XSP + 1
   \   000161   E0           MOVX      A,@DPTR
   \   000162   C0E0         PUSH      A
   \   000164   12....       LCALL     ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000167   D0E0         POP       A
   \   000169   F0           MOVX      @DPTR,A
    260                          uint8 fcs = MT_UartCalcFCS(0, &pMsgContent->len, 1);
   \   00016A   90....       MOV       DPTR,#pMsgContent
   \   00016D   E0           MOVX      A,@DPTR
   \   00016E   2402         ADD       A,#0x2
   \   000170   F5..         MOV       ?V0,A
   \   000172   A3           INC       DPTR
   \   000173   E0           MOVX      A,@DPTR
   \   000174   3400         ADDC      A,#0x0
   \   000176   F5..         MOV       ?V1,A
   \   000178                ; Setup parameters for call to function MT_UartCalcFCS
   \   000178   7C01         MOV       R4,#0x1
   \   00017A   AA..         MOV       R2,?V0
   \   00017C   FB           MOV       R3,A
   \   00017D   7900         MOV       R1,#0x0
   \   00017F   12....       LCALL     `??MT_UartCalcFCS::?relay`; Banked call to: MT_UartCalcFCS
   \   000182   E9           MOV       A,R1
   \   000183   F9           MOV       R1,A
    261                          fcs = MT_UartCalcFCS(fcs, pMsgContent->dataBody, pMsgContent->len);
   \   000184                ; Setup parameters for call to function MT_UartCalcFCS
   \   000184   85..82       MOV       DPL,?V0
   \   000187   85..83       MOV       DPH,?V1
   \   00018A   E0           MOVX      A,@DPTR
   \   00018B   FC           MOV       R4,A
   \   00018C   90....       MOV       DPTR,#pMsgContent
   \   00018F   E0           MOVX      A,@DPTR
   \   000190   2403         ADD       A,#0x3
   \   000192   FA           MOV       R2,A
   \   000193   A3           INC       DPTR
   \   000194   E0           MOVX      A,@DPTR
   \   000195   3400         ADDC      A,#0x0
   \   000197   FB           MOV       R3,A
   \   000198   12....       LCALL     `??MT_UartCalcFCS::?relay`; Banked call to: MT_UartCalcFCS
   \   00019B   E9           MOV       A,R1
   \   00019C   F9           MOV       R1,A
    262                          if(fcs == ch)
   \   00019D   85..82       MOV       DPL,?XSP + 0
   \   0001A0   85..83       MOV       DPH,?XSP + 1
   \   0001A3   E0           MOVX      A,@DPTR
   \   0001A4   69           XRL       A,R1
   \   0001A5   90....       MOV       DPTR,#pMsg
   \   0001A8   700F         JNZ       ??MT_UartProcessZToolData_11
    263                              osal_msg_send(App_TaskID, (byte *)pMsg);
   \   0001AA                ; Setup parameters for call to function osal_msg_send
   \   0001AA   E0           MOVX      A,@DPTR
   \   0001AB   FA           MOV       R2,A
   \   0001AC   A3           INC       DPTR
   \   0001AD   E0           MOVX      A,@DPTR
   \   0001AE   FB           MOV       R3,A
   \   0001AF   90....       MOV       DPTR,#App_TaskID
   \   0001B2   E0           MOVX      A,@DPTR
   \   0001B3   F9           MOV       R1,A
   \   0001B4   12....       LCALL     `??osal_msg_send::?relay`; Banked call to: osal_msg_send
   \   0001B7   8008         SJMP      ??MT_UartProcessZToolData_8
    264                          else
    265                              osal_msg_deallocate((uint8 *)pMsg);
   \                     ??MT_UartProcessZToolData_11:
   \   0001B9                ; Setup parameters for call to function osal_msg_deallocate
   \   0001B9   E0           MOVX      A,@DPTR
   \   0001BA   FA           MOV       R2,A
   \   0001BB   A3           INC       DPTR
   \   0001BC   E0           MOVX      A,@DPTR
   \   0001BD   FB           MOV       R3,A
   \   0001BE   12....       LCALL     `??osal_msg_deallocate::?relay`; Banked call to: osal_msg_deallocate
    266                      }
    267                      /* Reset the state, send or discard the buffers at this point */
    268                      state = SOP_STATE;
   \                     ??MT_UartProcessZToolData_8:
   \   0001C1   90....       MOV       DPTR,#state
   \   0001C4   E4           CLR       A
   \   0001C5   02....       LJMP      ??MT_UartProcessZToolData_2 & 0xFFFF
    269                      break;
    270                  default:
    271                      break;
    272                  }
    273              }
    274          }
   \                     ??MT_UartProcessZToolData_3:
   \   0001C8   7401         MOV       A,#0x1
   \   0001CA   12....       LCALL     ?DEALLOC_XSTACK8
   \   0001CD   7F02         MOV       R7,#0x2
   \   0001CF   02....       LJMP      ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_11:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   90....       MOV       DPTR,#pMsgContent
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F8           MOV       R0,A
   \   000005   A3           INC       DPTR
   \   000006   E0           MOVX      A,@DPTR
   \   000007   F583         MOV       DPH,A
   \   000009   8882         MOV       DPL,R0
   \   00000B   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   E0           MOVX      A,@DPTR
   \   000001   FA           MOV       R2,A
   \   000002   A3           INC       DPTR
   \   000003   E0           MOVX      A,@DPTR
   \   000004   F583         MOV       DPH,A
   \   000006   8A82         MOV       DPL,R2
   \   000008   A3           INC       DPTR
   \   000009   A3           INC       DPTR
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL     ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_10:
   \   000003   A3           INC       DPTR
   \   000004   A3           INC       DPTR
   \   000005   E0           MOVX      A,@DPTR
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL     ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_9:
   \   000003   AA82         MOV       R2,DPL
   \   000005   AB83         MOV       R3,DPH
   \   000007   EE           MOV       A,R6
   \   000008   F9           MOV       R1,A
   \   000009   12....       LCALL     `??HalUARTRead::?relay`; Banked call to: HalUARTRead
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   90....       MOV       DPTR,#pMsgContent
   \   000003   E0           MOVX      A,@DPTR
   \   000004   28           ADD       A,R0
   \   000005   FA           MOV       R2,A
   \   000006   A3           INC       DPTR
   \   000007   E0           MOVX      A,@DPTR
   \   000008   3400         ADDC      A,#0x0
   \   00000A   8A82         MOV       DPL,R2
   \   00000C   F583         MOV       DPH,A
   \   00000E   A3           INC       DPTR
   \   00000F   A3           INC       DPTR
   \   000010   A3           INC       DPTR
   \   000011   22           RET
    275          #if 0
    276          void MT_UartProcessAppData ( uint8 port, uint8 event )
    277          {
    278             uint8  *bytesInRxBuffer;
    279            static uint8 *msg;
    280          
    281            (void)event;  // Intentionally unreferenced parameter
    282            msg = (uint8 *)osal_msg_allocate(5);
    283            if(msg){
    284              bytesInRxBuffer = msg;
    285              *bytesInRxBuffer ++ = CMD_SERIAL_MSG;
    286            }
    287            while (Hal_UART_RxBufLen(port))
    288            {
    289              HalUARTRead (port, bytesInRxBuffer , 5);
    290              osal_msg_send( App_TaskID, (byte *)msg );
    291            }
    292          
    293          }
    294          #endif
    295          
    296          #endif
    297          #if defined (ZAPP_P1) || defined (ZAPP_P2)
    298          /***************************************************************************************************
    299           * @fn      MT_UartProcessZAppData
    300           *
    301           * @brief   | SOP | CMD  |   Data Length   | FSC  |
    302           *          |  1  |  2   |       1         |  1   |
    303           *
    304           *          Parses the data and determine either is SPI or just simply serial data
    305           *          then send the data to correct place (MT or APP)
    306           *
    307           * @param   port    - UART port
    308           *          event   - Event that causes the callback
    309           *
    310           *
    311           * @return  None
    312           ***************************************************************************************************/
    313          void MT_UartProcessZAppData ( uint8 port, uint8 event )
    314          {
    315          
    316            osal_event_hdr_t  *msg_ptr;
    317            uint16 length = 0;
    318            uint16 rxBufLen  = Hal_UART_RxBufLen(MT_UART_DEFAULT_PORT);
    319          
    320            /*
    321               If maxZAppBufferLength is 0 or larger than current length
    322               the entire length of the current buffer is returned.
    323            */
    324            if ((MT_UartMaxZAppBufLen != 0) && (MT_UartMaxZAppBufLen <= rxBufLen))
    325            {
    326              length = MT_UartMaxZAppBufLen;
    327            }
    328            else
    329            {
    330              length = rxBufLen;
    331            }
    332          
    333            /* Verify events */
    334            if (event == HAL_UART_TX_FULL)
    335            {
    336              // Do something when TX if full
    337              return;
    338            }
    339          
    340            if (event & ( HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT))
    341            {
    342              if ( App_TaskID )
    343              {
    344                /*
    345                   If Application is ready to receive and there is something
    346                   in the Rx buffer then send it up
    347                */
    348                if ((MT_UartZAppRxStatus == MT_UART_ZAPP_RX_READY ) && (length != 0))
    349                {
    350                  /* Disable App flow control until it processes the current data */
    351                   MT_UartAppFlowControl (MT_UART_ZAPP_RX_NOT_READY);
    352          
    353                  /* 2 more bytes are added, 1 for CMD type, other for length */
    354                  msg_ptr = (osal_event_hdr_t *)osal_msg_allocate( length + sizeof(osal_event_hdr_t) );
    355                  if ( msg_ptr )
    356                  {
    357                    msg_ptr->event = SPI_INCOMING_ZAPP_DATA;
    358                    msg_ptr->status = length;
    359          
    360                    /* Read the data of Rx buffer */
    361                    HalUARTRead( MT_UART_DEFAULT_PORT, (uint8 *)(msg_ptr + 1), length );
    362          
    363                    /* Send the raw data to application...or where ever */
    364                    osal_msg_send( App_TaskID, (uint8 *)msg_ptr );
    365                  }
    366                }
    367              }
    368            }
    369          }
    370          
    371          /***************************************************************************************************
    372           * @fn      SPIMgr_ZAppBufferLengthRegister
    373           *
    374           * @brief
    375           *
    376           * @param   maxLen - Max Length that the application wants at a time
    377           *
    378           * @return  None
    379           *
    380           ***************************************************************************************************/
    381          void MT_UartZAppBufferLengthRegister ( uint16 maxLen )
    382          {
    383            /* If the maxLen is larger than the RX buff, something is not right */
    384            if (maxLen <= MT_UART_DEFAULT_MAX_RX_BUFF)
    385              MT_UartMaxZAppBufLen = maxLen;
    386            else
    387              MT_UartMaxZAppBufLen = 1; /* default is 1 byte */
    388          }
    389          
    390          /***************************************************************************************************
    391           * @fn      SPIMgr_AppFlowControl
    392           *
    393           * @brief
    394           *
    395           * @param   status - ready to send or not
    396           *
    397           * @return  None
    398           *
    399           ***************************************************************************************************/
    400          void MT_UartAppFlowControl ( bool status )
    401          {
    402          
    403            /* Make sure only update if needed */
    404            if (status != MT_UartZAppRxStatus )
    405            {
    406              MT_UartZAppRxStatus = status;
    407            }
    408          
    409            /* App is ready to read again, ProcessZAppData have to be triggered too */
    410            if (status == MT_UART_ZAPP_RX_READY)
    411            {
    412              MT_UartProcessZAppData (MT_UART_DEFAULT_PORT, HAL_UART_RX_TIMEOUT );
    413            }
    414          
    415          }
    416          
    417          #endif //ZAPP
    418          
    419          /***************************************************************************************************
    420          ***************************************************************************************************/

   Maximum stack usage in bytes:

   ISTACK XSTACK Function
   ------ ------ --------
      0     20   MT_UartCalcFCS
      2     29   MT_UartInit
        2     29   -> HalUARTOpen
      1     11   MT_UartProcessZToolData
        0     11   -> HalUARTRead
        0     11   -> Hal_UART_RxBufLen
        0     11   -> MT_UartCalcFCS
        0     11   -> osal_msg_allocate
        0     11   -> osal_msg_deallocate
        0     11   -> osal_msg_send
      2      0   MT_UartRegisterTaskID


   Segment part sizes:

   Bytes  Function/Label
   -----  --------------
       7  ?Subroutine0
      13  ?Subroutine1
       7  ?Subroutine2
      11  ?Subroutine3
       4  ?Subroutine4
      18  ?Subroutine5
      12  ?Subroutine6
       1  App_TaskID
      33  MT_UartCalcFCS
     110  MT_UartInit
     466  MT_UartProcessZToolData
      11  MT_UartRegisterTaskID
       2  pMsg
       2  pMsgContent
       1  state
       1  tempDataLen
      24  -- Other

 
 692 bytes in segment BANKED_CODE
  24 bytes in segment BANK_RELAYS
   7 bytes in segment XDATA_Z
 
  24 bytes of CODE     memory
 692 bytes of HUGECODE memory
   7 bytes of XDATA    memory

Errors: none
Warnings: none
